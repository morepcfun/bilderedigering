<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Image Editor Online</title>
<meta name="description" content="A powerful in-browser image editor with layers. Crop, resize, add text, and export images in PNG, JPEG, or WEBP format.">
<meta name="author" content="Johnny Heggelund">
<style>
:root {
--bg-color: #1e1e1e;
--primary-color: #2d2d2d;
--secondary-color: #3c3c3c;
--text-color: #e0e0e0;
--accent-color: #007acc;
--border-color: #4a4a4a;
--font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
body,
html {
margin: 0;
padding: 0;
width: 100%;
height: 100vh;
font-family: var(--font-family);
background-color: var(--bg-color);
color: var(--text-color);
overflow: hidden;
}
body {
display: grid;
grid-template-rows: auto 1fr;
}
.main-container {
display: flex;
overflow: hidden;
position: relative;
}
.toolbar {
background-color: var(--primary-color);
padding: 8px;
display: flex;
flex-direction: column;
gap: 10px;
width: 60px;
border-right: 1px solid var(--border-color);
align-items: center;
z-index: 5;
}
.tool-btn {
background-color: var(--secondary-color);
border: 1px solid var(--border-color);
color: var(--text-color);
cursor: pointer;
padding: 8px;
width: 42px;
height: 42px;
font-size: 20px;
border-radius: 4px;
transition: background-color 0.2s;
display: flex;
align-items: center;
justify-content: center;
}
.tool-btn:hover {
background-color: var(--accent-color);
}
.tool-btn.active {
background-color: var(--accent-color);
border: 1px solid var(--text-color);
}
.options-bar {
background-color: var(--primary-color);
padding: 5px 15px;
border-bottom: 1px solid var(--border-color);
display: flex;
align-items: center;
gap: 10px;
min-height: 40px;
flex-wrap: wrap;
position: relative;
z-index: 10;
}
.options-bar label,
.options-bar button,
.options-bar input,
.options-bar select,
.options-bar span {
margin: 0;
font-size: 13px;
align-items: center;
display: flex;
}
.options-bar input[type="number"],
.options-bar input[type="text"],
.options-bar input[type="color"],
.options-bar select {
background-color: var(--secondary-color);
color: var(--text-color);
border: 1px solid var(--border-color);
border-radius: 3px;
padding: 3px 5px;
max-width: 80px;
transition: border-color 0.2s;
}
.options-bar input#text-input {
max-width: 180px;
}
.options-bar input::placeholder {
color: #9e9e9e;
opacity: 1;
}
.options-bar input:focus,
.options-bar select:focus {
outline: none;
border-color: var(--accent-color);
}
.options-bar button {
background-color: var(--accent-color);
color: var(--text-color);
border: none;
padding: 4px 10px;
border-radius: 3px;
cursor: pointer;
}
.options-bar .separator {
width: 1px;
height: 25px;
background-color: var(--border-color);
margin: 0 5px;
}
.canvas-container {
flex: 1;
display: grid;
place-items: center;
overflow: hidden;
background-image: linear-gradient(45deg, #2a2a2a 25%, transparent 25%), linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #2a2a2a 75%), linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
background-size: 20px 20px;
background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
position: relative;
}
canvas {
box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
cursor: default;
}
.right-panel {
width: 200px;
background-color: var(--primary-color);
border-left: 1px solid var(--border-color);
display: flex;
flex-direction: column;
overflow-y: auto;
z-index: 5;
}
.panel-section {
padding: 10px;
border-bottom: 1px solid var(--border-color);
}
.panel-section h4 {
margin: 0 0 10px 0;
font-size: 14px;
border-bottom: 1px solid var(--border-color);
padding-bottom: 5px;
}
#layers-list {
list-style: none;
padding: 0;
margin: 0;
max-height: 300px;
overflow-y: auto;
}
#layers-list li {
background-color: var(--secondary-color);
padding: 8px;
margin-bottom: 5px;
cursor: pointer;
border: 1px solid transparent;
border-radius: 3px;
font-size: 13px;
display: flex;
justify-content: space-between;
align-items: center;
}
#layers-list li.active {
border: 1px solid var(--accent-color);
background-color: #4a4a4a;
}
#layers-list li .visibility-toggle {
cursor: pointer;
opacity: 0.7;
}
#layers-list li .visibility-toggle:hover {
opacity: 1;
}
.layer-controls {
display: flex;
gap: 5px;
margin-top: 10px;
}
.layer-controls button {
flex: 1;
padding: 5px;
font-size: 16px;
}
#export-preview {
max-width: 100%;
height: auto;
margin-top: 10px;
border: 1px solid var(--border-color);
}
#file-size-info {
font-size: 12px;
margin-top: 5px;
text-align: center;
}
#crop-info {
position: fixed;
background-color: rgba(0, 0, 0, 0.7);
color: white;
padding: 3px 6px;
font-size: 12px;
border-radius: 3px;
pointer-events: none;
display: none;
z-index: 20;
transform: translate(15px, 15px);
}
#zoom-display {
font-size: 13px;
color: var(--text-color);
min-width: 50px;
text-align: center;
}
h1 {
color: #808080;
font-size: 0.8rem;
margin-top: 0;
margin-bottom: 12px;
}
</style>
</head>
<body>
<input type="file" id="file-input" accept="image/*" style="display: none;">
<div class="options-bar">
<button id="open-btn"></button>
<button id="export-btn"></button>
<button id="paste-btn"></button>
<div class="separator"></div>
<label for="resize-width" id="width-label"></label>
<input type="number" id="resize-width" min="1">
<label for="resize-height" id="height-label"></label>
<input type="number" id="resize-height" min="1">
<label id="keep-proportions-label"><input type="checkbox" id="keep-proportions" checked> üîó</label>
<button id="resize-btn"></button>
<div class="separator"></div>
<button id="zoom-out-btn">-</button>
<button id="fit-to-screen-btn">[ ]</button>
<button id="zoom-in-btn">+</button>
<span id="zoom-display">100%</span>
<div class="separator"></div>
<div id="crop-options" style="display: none; align-items: center; gap: 10px;">
<button id="apply-crop-btn"></button>
</div>
<div id="text-options" style="display: none; align-items: center; gap: 15px;">
<input type="text" id="text-input">
<input type="color" id="text-color" value="#000000">
<select id="font-select">
<option>Arial</option>
<option>Verdana</option>
<option>Times New Roman</option>
<option>Courier New</option>
<option>Impact</option>
</select>
<input type="number" id="font-size" value="48" min="1">
<button id="add-text-btn"></button>
<div class="separator"></div>
<label><input type="checkbox" id="text-shadow"> <span id="shadow-label"></span></label>
</div>
</div>
<div class="main-container">
<div class="toolbar">
<button class="tool-btn active" id="tool-move">V</button>
<button class="tool-btn" id="tool-crop">C</button>
<button class="tool-btn" id="tool-text">T</button>
</div>
<div class="canvas-container" id="canvas-container">
<canvas id="canvas"></canvas>
<div id="crop-info"></div>
</div>
<div class="right-panel">
<div class="panel-section">
<h4 id="layers-title"></h4>
<ul id="layers-list"></ul>
<div class="layer-controls"><button id="layer-up-btn">‚ñ≤</button><button id="layer-down-btn">‚ñº</button><button id="layer-delete-btn">üóëÔ∏è</button></div>
</div>
<div class="panel-section">
<h4 id="export-title"></h4><label for="export-format" id="format-label"></label><select id="export-format">
<option value="image/png">PNG</option>
<option value="image/jpeg">JPEG</option>
<option value="image/webp">WEBP</option>
</select>
<div id="quality-control" style="display:none; margin-top: 10px;"><label for="export-quality" id="quality-label"></label><input type="range" id="export-quality" min="0.1" max="1" step="0.1" value="0.9"></div><img id="export-preview" src="" alt="">
<div id="file-size-info"></div>
</div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
const lang = {
open: "Open",
export: "Export",
paste: "Paste",
width: "Width:",
height: "Height:",
keepAspectRatio: "Keep aspect ratio",
resize: "Resize",
zoomOut: "Zoom out",
fitToScreen: "Fit to screen",
zoomIn: "Zoom in",
applyCrop: "Apply crop",
textInputPlaceholder: "Type text here...",
addText: "Add text",
shadow: "Shadow",
toolMove: "Move (V)",
toolCrop: "Crop (C)",
toolText: "Text (T)",
layers: "Layers",
moveUp: "Move up",
moveDown: "Move down",
delete: "Delete",
showHideLayer: "Show/hide layer",
exportTitle: "Export",
format: "Format:",
quality: "Quality:",
previewAlt: "Preview",
fileSize: "Size:",
pastedImage: "Pasted image",
croppedImage: "Cropped image",
resizedImage: "Resized image",
textLayer: "Text:",
backgroundLayer: "Background",
cropConfirm: "Cropping will merge all layers into one. Do you want to continue?",
resizeConfirm: "Resizing will merge all layers into one. Do you want to continue?",
invalidSize: "Invalid width/height.",
noImageOnClipboard: "No image found on clipboard.",
pasteError: "Could not paste. Check console for error message.",
clipboardDenied: "Clipboard access denied."
};
document.title = "Image Editor";
const canvas = document.getElementById('canvas');
const canvasContainer = document.getElementById('canvas-container');
const ctx = canvas.getContext('2d');
let layers = [];
let activeLayerIndex = -1;
let currentTool = 'move';
let isDragging = false, isCropping = false, isPanning = false, isResizing = false;
let isMovingCrop = false, isResizingCrop = false;
let startX, startY, dragOffsetX, dragOffsetY, originalLayerState;
let cropRect = { x: 0, y: 0, w: 0, h: 0 };
let zoom = 1.0, panX = 0, panY = 0;
let logicalWidth = 800, logicalHeight = 600;
let currentAspectRatio = logicalWidth / logicalHeight;
let activeHandle = null;
const fileInput = document.getElementById('file-input'), openBtn = document.getElementById('open-btn'),
exportBtn = document.getElementById('export-btn'), pasteBtn = document.getElementById('paste-btn'),
zoomInBtn = document.getElementById('zoom-in-btn'), zoomOutBtn = document.getElementById('zoom-out-btn'),
fitToScreenBtn = document.getElementById('fit-to-screen-btn'), zoomDisplay = document.getElementById('zoom-display'),
layersList = document.getElementById('layers-list'), textOptions = document.getElementById('text-options'),
cropOptions = document.getElementById('crop-options'), addTextBtn = document.getElementById('add-text-btn'),
applyCropBtn = document.getElementById('apply-crop-btn'), resizeWidthInput = document.getElementById('resize-width'),
resizeHeightInput = document.getElementById('resize-height'), resizeBtn = document.getElementById('resize-btn'),
keepProportionsCheckbox = document.getElementById('keep-proportions'),
layerUpBtn = document.getElementById('layer-up-btn'), layerDownBtn = document.getElementById('layer-down-btn'),
layerDeleteBtn = document.getElementById('layer-delete-btn'), exportFormatSelect = document.getElementById('export-format'),
qualityControl = document.getElementById('quality-control'), exportQualitySlider = document.getElementById('export-quality'),
exportPreview = document.getElementById('export-preview'), fileSizeInfo = document.getElementById('file-size-info'),
cropInfo = document.getElementById('crop-info'), toolMoveBtn = document.getElementById('tool-move'),
toolCropBtn = document.getElementById('tool-crop'), toolTextBtn = document.getElementById('tool-text');
function updateStaticUIText() {
openBtn.textContent = lang.open;
exportBtn.textContent = lang.export;
pasteBtn.textContent = lang.paste;
document.getElementById('width-label').textContent = lang.width;
document.getElementById('height-label').textContent = lang.height;
document.getElementById('keep-proportions-label').title = lang.keepAspectRatio;
resizeBtn.textContent = lang.resize;
zoomOutBtn.title = lang.zoomOut;
fitToScreenBtn.title = lang.fitToScreen;
zoomInBtn.title = lang.zoomIn;
applyCropBtn.textContent = lang.applyCrop;
document.getElementById('text-input').placeholder = lang.textInputPlaceholder;
addTextBtn.textContent = lang.addText;
document.getElementById('shadow-label').textContent = lang.shadow;
toolMoveBtn.title = lang.toolMove;
toolCropBtn.title = lang.toolCrop;
toolTextBtn.title = lang.toolText;
document.getElementById('layers-title').textContent = lang.layers;
layerUpBtn.title = lang.moveUp;
layerDownBtn.title = lang.moveDown;
layerDeleteBtn.title = lang.delete;
document.getElementById('export-title').textContent = lang.exportTitle;
document.getElementById('format-label').textContent = lang.format;
document.getElementById('quality-label').textContent = lang.quality;
exportPreview.alt = lang.previewAlt;
}
const getHandles = (rect) => {
const { x, y, w, h } = rect;
return {
topLeft: { x, y }, topMiddle: { x: x + w / 2, y }, topRight: { x: x + w, y },
middleLeft: { x, y: y + h / 2 }, middleRight: { x: x + w, y: y + h / 2 },
bottomLeft: { x, y: y + h }, bottomMiddle: { x: x + w / 2, y: y + h }, bottomRight: { x: x + w, y: y + h },
};
};
const getCursorForHandle = (handleName) => {
switch (handleName) {
case 'topLeft': case 'bottomRight': return 'nwse-resize';
case 'topRight': case 'bottomLeft': return 'nesw-resize';
case 'topMiddle': case 'bottomMiddle': return 'ns-resize';
case 'middleLeft': case 'middleRight': return 'ew-resize';
default: return 'grab';
}
};
const getNormalizedRect = (rect) => {
return {
x: rect.w < 0 ? rect.x + rect.w : rect.x,
y: rect.h < 0 ? rect.y + rect.h : rect.y,
w: Math.abs(rect.w),
h: Math.abs(rect.h),
};
};
const updateCanvasSize = () => {
const rect = canvasContainer.getBoundingClientRect();
canvas.style.width = `${rect.width}px`;
canvas.style.height = `${rect.height}px`;
const dpr = window.devicePixelRatio || 1;
canvas.width = rect.width * dpr;
canvas.height = rect.height * dpr;
ctx.scale(dpr, dpr);
redrawCanvas();
};
const redrawCanvas = () => {
const dpr = window.devicePixelRatio || 1;
ctx.save();
ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
ctx.clearRect(0, 0, canvas.width, canvas.height);
const viewWidth = canvas.width / dpr;
const viewHeight = canvas.height / dpr;
ctx.translate(viewWidth / 2, viewHeight / 2);
ctx.translate(panX, panY);
ctx.scale(zoom, zoom);
ctx.translate(-logicalWidth / 2, -logicalHeight / 2);
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, logicalWidth, logicalHeight);
layers.forEach(layer => {
if (!layer.visible) return;
ctx.save();
if (layer.type === 'image') {
ctx.drawImage(layer.content, layer.x, layer.y, layer.width, layer.height);
} else if (layer.type === 'text') {
ctx.font = `${layer.fontSize}px ${layer.font}`;
ctx.fillStyle = layer.color;
if (layer.shadow) { ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5; ctx.shadowOffsetX = 3; ctx.shadowOffsetY = 3; }
ctx.textBaseline = 'top';
ctx.fillText(layer.content, layer.x, layer.y);
}
ctx.restore();
});
if (activeLayerIndex !== -1 && layers[activeLayerIndex]?.visible && currentTool === 'move') {
const layer = layers[activeLayerIndex];
ctx.strokeStyle = 'rgba(0, 122, 204, 0.8)';
ctx.lineWidth = 2 / zoom;
ctx.strokeRect(layer.x, layer.y, layer.width, layer.height);
drawHandles(getHandles({ x: layer.x, y: layer.y, w: layer.width, h: layer.height }));
}
if (currentTool === 'crop' && cropRect.w !== 0 && cropRect.h !== 0) {
const normCrop = getNormalizedRect(cropRect);
ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
ctx.beginPath();
ctx.rect(normCrop.x, normCrop.y, normCrop.w, normCrop.h);
ctx.rect(0, 0, logicalWidth, logicalHeight);
ctx.closePath();
ctx.fill('evenodd');
ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
ctx.lineWidth = 1 / zoom;
ctx.strokeRect(normCrop.x, normCrop.y, normCrop.w, normCrop.h);
drawHandles(getHandles(normCrop));
}
ctx.restore();
};
const drawHandles = (handles) => {
const handleSize = 8 / zoom;
ctx.fillStyle = 'white';
ctx.strokeStyle = 'black';
ctx.lineWidth = 1 / zoom;
for (const handle in handles) {
const pos = handles[handle];
ctx.fillRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
ctx.strokeRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
}
};
const getMousePos = (e) => {
const rect = canvas.getBoundingClientRect();
const viewWidth = rect.width;
const viewHeight = rect.height;
const mouseX = e.clientX - rect.left;
const mouseY = e.clientY - rect.top;
const worldX = (mouseX - viewWidth / 2 - panX) / zoom + logicalWidth / 2;
const worldY = (mouseY - viewHeight / 2 - panY) / zoom + logicalHeight / 2;
return { x: worldX, y: worldY };
};
const fitToScreen = () => {
const rect = canvasContainer.getBoundingClientRect();
const padding = 40;
const availableWidth = rect.width - padding;
const availableHeight = rect.height - padding;
const scale = Math.min(availableWidth / logicalWidth, availableHeight / logicalHeight);
zoom = scale;
panX = 0;
panY = 0;
zoomDisplay.textContent = `${(zoom * 100).toFixed(0)}%`;
redrawCanvas();
};
const doZoom = (delta, centerX, centerY) => {
const rect = canvas.getBoundingClientRect();
const viewWidth = rect.width;
const viewHeight = rect.height;
const mouseX = centerX ?? viewWidth / 2;
const mouseY = centerY ?? viewHeight / 2;
const worldX_before = (mouseX - viewWidth / 2 - panX) / zoom + logicalWidth / 2;
const worldY_before = (mouseY - viewHeight / 2 - panY) / zoom + logicalHeight / 2;
const oldZoom = zoom;
zoom = Math.max(0.02, Math.min(32, zoom * (1 + delta)));
panX += (worldX_before - logicalWidth / 2) * (oldZoom - zoom);
panY += (worldY_before - logicalHeight / 2) * (oldZoom - zoom);
zoomDisplay.textContent = `${(zoom * 100).toFixed(0)}%`;
redrawCanvas();
};
const createFlattenedCanvas = () => {
const tempCanvas = document.createElement('canvas');
tempCanvas.width = logicalWidth; tempCanvas.height = logicalHeight;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.fillStyle = 'white'; tempCtx.fillRect(0, 0, logicalWidth, logicalHeight);
layers.forEach(layer => {
if (!layer.visible) return;
if (layer.type === 'image') { tempCtx.drawImage(layer.content, layer.x, layer.y, layer.width, layer.height); }
else if (layer.type === 'text') {
tempCtx.save();
tempCtx.font = `${layer.fontSize}px ${layer.font}`; tempCtx.fillStyle = layer.color;
if (layer.shadow) { tempCtx.shadowColor = 'rgba(0,0,0,0.5)'; tempCtx.shadowBlur = 5; tempCtx.shadowOffsetX = 3; tempCtx.shadowOffsetY = 3; }
tempCtx.textBaseline = 'top'; tempCtx.fillText(layer.content, layer.x, layer.y);
tempCtx.restore();
}
});
return tempCanvas;
};
const updateLayersList = () => {
layersList.innerHTML = '';
[...layers].reverse().forEach((layer, index) => {
const reversedIndex = layers.length - 1 - index;
const li = document.createElement('li'); li.textContent = `${layer.name}`; li.dataset.index = reversedIndex;
if (reversedIndex === activeLayerIndex) li.classList.add('active');
const visibilityToggle = document.createElement('span'); visibilityToggle.className = 'visibility-toggle';
visibilityToggle.innerHTML = layer.visible ? 'üëÅÔ∏è' : 'üôà'; visibilityToggle.title = lang.showHideLayer;
visibilityToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleLayerVisibility(reversedIndex); });
li.prepend(visibilityToggle); li.addEventListener('click', () => setActiveLayer(reversedIndex));
layersList.appendChild(li);
});
};
const toggleLayerVisibility = (index) => { layers[index].visible = !layers[index].visible; redrawCanvas(); updateLayersList(); updateExportPreview(); };
const setActiveLayer = (index) => { activeLayerIndex = index; updateLayersList(); redrawCanvas(); };
const addLayer = (layer, center = false) => {
if (center) {
layer.x = (logicalWidth - layer.width) / 2;
layer.y = (logicalHeight - layer.height) / 2;
}
layers.push(layer);
setActiveLayer(layers.length - 1);
updateExportPreview();
};
const moveLayer = (direction) => {
if (activeLayerIndex < 0) return;
const newIndex = activeLayerIndex + direction;
if (newIndex < 0 || newIndex >= layers.length) return;
[layers[activeLayerIndex], layers[newIndex]] = [layers[newIndex], layers[activeLayerIndex]];
setActiveLayer(newIndex);
updateExportPreview();
};
const switchTool = (tool) => {
if (document.querySelector('.tool-btn.active')) {
document.querySelector('.tool-btn.active').classList.remove('active');
}
document.getElementById(`tool-${tool}`).classList.add('active');
currentTool = tool;
textOptions.style.display = tool === 'text' ? 'flex' : 'none';
cropOptions.style.display = 'none';
if (tool !== 'crop' && cropRect.w !== 0) {
cropRect = { x: 0, y: 0, w: 0, h: 0 };
} else if (tool === 'crop' && cropRect.w !== 0) {
cropOptions.style.display = 'flex';
}
canvas.style.cursor = tool === 'crop' ? 'crosshair' : (tool === 'move' ? 'grab' : 'default');
redrawCanvas();
};
const updateExportPreview = () => {
const tempCanvas = createFlattenedCanvas();
const format = exportFormatSelect.value;
const quality = parseFloat(exportQualitySlider.value);
qualityControl.style.display = ['image/jpeg', 'image/webp'].includes(format) ? 'block' : 'none';
tempCanvas.toBlob(blob => {
if (blob) {
if (exportPreview.src) URL.revokeObjectURL(exportPreview.src);
const url = URL.createObjectURL(blob);
exportPreview.src = url;
fileSizeInfo.textContent = `${lang.fileSize} ${(blob.size / 1024).toFixed(2)} KB`;
}
}, format, quality);
};
const applyCrop = () => {
if (Math.abs(cropRect.w) < 1 || Math.abs(cropRect.h) < 1) return;
if (!confirm(lang.cropConfirm)) return;
const normCrop = getNormalizedRect(cropRect);
const newWidth = Math.round(normCrop.w), newHeight = Math.round(normCrop.h);
const flattenedCanvas = createFlattenedCanvas();
const tempCanvas = document.createElement('canvas'); tempCanvas.width = newWidth; tempCanvas.height = newHeight;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.drawImage(flattenedCanvas, normCrop.x, normCrop.y, normCrop.w, normCrop.h, 0, 0, newWidth, newHeight);
logicalWidth = newWidth; logicalHeight = newHeight;
currentAspectRatio = newWidth / newHeight;
resizeWidthInput.value = newWidth; resizeHeightInput.value = newHeight;
const newImg = new Image();
newImg.onload = () => {
layers = [{ type: 'image', name: lang.croppedImage, content: newImg, x: 0, y: 0, width: newWidth, height: newHeight, visible: true }];
setActiveLayer(0); switchTool('move'); fitToScreen();
};
newImg.src = tempCanvas.toDataURL();
};
const pasteFromClipboard = async () => {
try {
const permission = await navigator.permissions.query({ name: 'clipboard-read' });
if (permission.state === 'denied') {
throw new Error(lang.clipboardDenied);
}
const clipboardItems = await navigator.clipboard.read();
for (const item of clipboardItems) {
const imageType = item.types.find(type => type.startsWith('image/'));
if (imageType) {
const blob = await item.getType(imageType);
const img = new Image();
img.onload = () => {
addLayer({
type: 'image', name: lang.pastedImage, content: img,
x: 0, y: 0, width: img.width, height: img.height, visible: true
}, true);
URL.revokeObjectURL(img.src);
};
img.src = URL.createObjectURL(blob);
return;
}
}
alert(lang.noImageOnClipboard);
} catch (err) {
console.error('Could not paste from clipboard:', err);
alert(lang.pasteError);
}
};
const loadImage = (img, fileName) => {
logicalWidth = img.width; logicalHeight = img.height;
currentAspectRatio = logicalWidth / logicalHeight;
resizeWidthInput.value = img.width; resizeHeightInput.value = img.height;
layers = [{ type: 'image', name: fileName, content: img, x: 0, y: 0, width: img.width, height: img.height, visible: true }];
setActiveLayer(0);
fitToScreen();
updateExportPreview();
};
toolMoveBtn.addEventListener('click', () => switchTool('move'));
toolCropBtn.addEventListener('click', () => switchTool('crop'));
toolTextBtn.addEventListener('click', () => switchTool('text'));
openBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', (e) => {
const file = e.target.files[0]; if (!file) return;
const reader = new FileReader();
reader.onload = (event) => {
const img = new Image();
img.onload = () => loadImage(img, file.name);
img.src = event.target.result;
};
reader.readAsDataURL(file); fileInput.value = '';
});
resizeWidthInput.addEventListener('input', () => {
if (keepProportionsCheckbox.checked) {
const newWidth = parseInt(resizeWidthInput.value, 10);
if (!isNaN(newWidth) && newWidth > 0) { resizeHeightInput.value = Math.round(newWidth / currentAspectRatio); }
}
});
resizeHeightInput.addEventListener('input', () => {
if (keepProportionsCheckbox.checked) {
const newHeight = parseInt(resizeHeightInput.value, 10);
if (!isNaN(newHeight) && newHeight > 0) { resizeWidthInput.value = Math.round(newHeight * currentAspectRatio); }
}
});
canvasContainer.addEventListener('wheel', (e) => {
e.preventDefault();
const delta = e.deltaY > 0 ? -0.1 : 0.1;
if (e.ctrlKey || e.metaKey) { doZoom(delta, e.offsetX, e.offsetY); }
else { panX -= e.deltaX; panY -= e.deltaY; redrawCanvas(); }
}, { passive: false });
zoomInBtn.addEventListener('click', () => doZoom(0.2));
zoomOutBtn.addEventListener('click', () => doZoom(-0.2));
fitToScreenBtn.addEventListener('click', fitToScreen);
document.addEventListener('keydown', (e) => {
if (document.activeElement.tagName.match(/INPUT|SELECT/)) return;
if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') { e.preventDefault(); pasteFromClipboard(); return; }
const toolMap = { v: 'move', c: 'crop', t: 'text' };
if (toolMap[e.key.toLowerCase()]) switchTool(toolMap[e.key.toLowerCase()]);
if (e.key === 'Delete' || e.key === 'Backspace') { if (activeLayerIndex > -1) { layers.splice(activeLayerIndex, 1); setActiveLayer(layers.length > 0 ? 0 : -1); updateLayersList(); redrawCanvas(); updateExportPreview(); } }
if (e.key === 'Enter' && currentTool === 'crop' && Math.abs(cropRect.w) > 0) applyCrop();
});
canvas.addEventListener('mousedown', (e) => {
if (e.button === 1 || (e.button === 0 && e.altKey && currentTool !== 'move')) { isPanning = true; canvas.style.cursor = 'grabbing'; return; }
if (e.button !== 0) return;
const pos = getMousePos(e);
startX = pos.x; startY = pos.y;
if (currentTool === 'move' && activeLayerIndex !== -1) {
const layer = layers[activeLayerIndex];
const handles = getHandles({ x: layer.x, y: layer.y, w: layer.width, h: layer.height });
const handleSize = 10 / zoom;
for (const handleName in handles) {
const handlePos = handles[handleName];
if (Math.abs(pos.x - handlePos.x) < handleSize / 2 && Math.abs(pos.y - handlePos.y) < handleSize / 2) {
isResizing = true; activeHandle = handleName;
originalLayerState = { ...layer };
canvas.style.cursor = getCursorForHandle(handleName);
return;
}
}
}
if (currentTool === 'crop' && cropRect.w !== 0 && cropRect.h !== 0) {
const normCrop = getNormalizedRect(cropRect);
const handles = getHandles(normCrop);
const handleSize = 10 / zoom;
for (const handleName in handles) {
const handlePos = handles[handleName];
if (Math.abs(pos.x - handlePos.x) < handleSize / 2 && Math.abs(pos.y - handlePos.y) < handleSize / 2) {
isResizingCrop = true; activeHandle = handleName;
originalLayerState = { ...cropRect };
canvas.style.cursor = getCursorForHandle(handleName);
return;
}
}
if (pos.x >= normCrop.x && pos.x <= normCrop.x + normCrop.w && pos.y >= normCrop.y && pos.y <= normCrop.y + normCrop.h) {
isMovingCrop = true;
dragOffsetX = pos.x - cropRect.x;
dragOffsetY = pos.y - cropRect.y;
canvas.style.cursor = 'move';
return;
}
}
if (currentTool === 'move') {
let clickedIdx = -1;
for (let i = layers.length - 1; i >= 0; i--) {
const l = layers[i];
if (l.visible && pos.x >= l.x && pos.x <= l.x + l.width && pos.y >= l.y && pos.y <= l.y + l.height) { clickedIdx = i; break; }
}
if (clickedIdx !== -1) {
isDragging = true; setActiveLayer(clickedIdx); dragOffsetX = pos.x - layers[clickedIdx].x; dragOffsetY = pos.y - layers[clickedIdx].y; canvas.style.cursor = 'grabbing';
}
} else if (currentTool === 'crop') {
isCropping = true; cropRect = { x: startX, y: startY, w: 0, h: 0 };
cropOptions.style.display = 'none';
}
});
canvas.addEventListener('mousemove', (e) => {
if (isPanning) { panX += e.movementX; panY += e.movementY; redrawCanvas(); return; }
const pos = getMousePos(e);
if (isResizing) {
const layer = layers[activeLayerIndex];
const dx = pos.x - startX;
const dy = pos.y - startY;
let { x, y, width, height } = originalLayerState;
const aspect = width / height;
let newX = x, newY = y, newW = width, newH = height;
switch (activeHandle) {
case 'topLeft':
newW = width - dx; newH = height - dy; newX = x + dx; newY = y + dy;
if (e.shiftKey) { newH = newW / aspect; newY = y + (height - newH); }
break;
case 'topMiddle':
newH = height - dy; newY = y + dy;
break;
case 'topRight':
newW = width + dx; newH = height - dy; newY = y + dy;
if (e.shiftKey) { newH = newW / aspect; newY = y + (height - newH); }
break;
case 'middleLeft':
newW = width - dx; newX = x + dx;
break;
case 'middleRight':
newW = width + dx;
break;
case 'bottomLeft':
newW = width - dx; newH = height + dy; newX = x + dx;
if (e.shiftKey) { newH = newW / aspect; }
break;
case 'bottomMiddle':
newH = height + dy;
break;
case 'bottomRight':
newW = width + dx; newH = height + dy;
if (e.shiftKey) { newH = newW / aspect; }
break;
}
if (e.altKey) {
const dW = newW - width;
const dH = newH - height;
newX -= dW / 2;
newY -= dH / 2;
}
if (layer.type === 'text') {
const scaleFactor = newW / originalLayerState.width;
const newFontSize = originalLayerState.fontSize * scaleFactor;
if (newFontSize >= 5) {
layer.fontSize = newFontSize;
ctx.font = `${layer.fontSize}px ${layer.font}`;
const metrics = ctx.measureText(layer.content);
layer.width = metrics.width;
layer.height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
layer.x = newX;
layer.y = newY;
}
} else {
if (newW > 10) { layer.x = newX; layer.width = newW; }
if (newH > 10) { layer.y = newY; layer.height = newH; }
}
redrawCanvas();
return;
}
if (isResizingCrop) {
const dx = pos.x - startX;
const dy = pos.y - startY;
let { x, y, w, h } = originalLayerState;
switch (activeHandle) {
case 'topLeft':
w -= dx; h -= dy; x += dx; y += dy;
break;
case 'topMiddle':
h -= dy; y += dy;
break;
case 'topRight':
w += dx; h -= dy; y += dy;
break;
case 'middleLeft':
w -= dx; x += dx;
break;
case 'middleRight':
w += dx;
break;
case 'bottomLeft':
w -= dx; h += dy; x += dx;
break;
case 'bottomMiddle':
h += dy;
break;
case 'bottomRight':
w += dx; h += dy;
break;
}
cropRect = { x, y, w, h };
const normCrop = getNormalizedRect(cropRect);
cropInfo.style.display = 'block';
cropInfo.style.left = `${e.clientX}px`;
cropInfo.style.top = `${e.clientY}px`;
cropInfo.textContent = `${Math.round(normCrop.w)} x ${Math.round(normCrop.h)} px`;
redrawCanvas();
return;
}
if (isMovingCrop) {
cropRect.x = pos.x - dragOffsetX;
cropRect.y = pos.y - dragOffsetY;
redrawCanvas();
}
if (isDragging) {
layers[activeLayerIndex].x = pos.x - dragOffsetX;
layers[activeLayerIndex].y = pos.y - dragOffsetY;
redrawCanvas();
} else if (isCropping) {
cropRect.w = pos.x - startX; cropRect.h = pos.y - startY;
const normCrop = getNormalizedRect(cropRect);
cropInfo.style.display = 'block';
cropInfo.style.left = `${e.clientX}px`;
cropInfo.style.top = `${e.clientY}px`;
cropInfo.textContent = `${Math.round(normCrop.w)} x ${Math.round(normCrop.h)} px`;
redrawCanvas();
} else {
let newCursor = 'default';
if (currentTool === 'move') {
newCursor = 'grab';
if (activeLayerIndex !== -1) {
const layer = layers[activeLayerIndex];
const handles = getHandles({ x: layer.x, y: layer.y, w: layer.width, h: layer.height });
const handleSize = 10 / zoom;
for (const handleName in handles) {
const handlePos = handles[handleName];
if (Math.abs(pos.x - handlePos.x) < handleSize / 2 && Math.abs(pos.y - handlePos.y) < handleSize / 2) {
newCursor = getCursorForHandle(handleName); break;
}
}
}
} else if (currentTool === 'crop') {
newCursor = 'crosshair';
if (cropRect.w !== 0) {
const normCrop = getNormalizedRect(cropRect);
const handles = getHandles(normCrop);
const handleSize = 10 / zoom;
let onHandle = false;
for (const handleName in handles) {
const handlePos = handles[handleName];
if (Math.abs(pos.x - handlePos.x) < handleSize / 2 && Math.abs(pos.y - handlePos.y) < handleSize / 2) {
newCursor = getCursorForHandle(handleName); onHandle = true; break;
}
}
if (!onHandle && pos.x >= normCrop.x && pos.x <= normCrop.x + normCrop.w && pos.y >= normCrop.y && pos.y <= normCrop.y + normCrop.h) {
newCursor = 'move';
}
}
}
canvas.style.cursor = newCursor;
}
});
window.addEventListener('mouseup', (e) => {
if (isCropping || isResizingCrop) {
if (cropRect.w < 0) { cropRect.x += cropRect.w; cropRect.w = -cropRect.w; }
if (cropRect.h < 0) { cropRect.y += cropRect.h; cropRect.h = -cropRect.h; }
}
if (isCropping) {
isCropping = false;
cropInfo.style.display = 'none';
if (Math.abs(cropRect.w) > 5 || Math.abs(cropRect.h) > 5) {
cropOptions.style.display = 'flex';
} else {
cropOptions.style.display = 'none';
cropRect = { x: 0, y: 0, w: 0, h: 0 };
redrawCanvas();
}
}
if (isResizing || isDragging) {
updateExportPreview();
}
isPanning = isDragging = isResizing = isMovingCrop = isResizingCrop = false;
activeHandle = null;
});
resizeBtn.addEventListener('click', () => {
const newWidth = parseInt(resizeWidthInput.value, 10);
const newHeight = parseInt(resizeHeightInput.value, 10);
if (isNaN(newWidth) || isNaN(newHeight) || newWidth <= 0 || newHeight <= 0) { return alert(lang.invalidSize); }
if (!confirm(lang.resizeConfirm)) return;
currentAspectRatio = newWidth / newHeight;
const flattenedCanvas = createFlattenedCanvas();
const tempCanvas = document.createElement('canvas'); tempCanvas.width = newWidth; tempCanvas.height = newHeight;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.imageSmoothingQuality = 'high';
tempCtx.drawImage(flattenedCanvas, 0, 0, logicalWidth, logicalHeight, 0, 0, newWidth, newHeight);
logicalWidth = newWidth; logicalHeight = newHeight;
const img = new Image();
img.onload = () => {
layers = [{ type: 'image', name: lang.resizedImage, content: img, x: 0, y: 0, width: newWidth, height: newHeight, visible: true }];
setActiveLayer(0); fitToScreen();
};
img.src = tempCanvas.toDataURL();
});
addTextBtn.addEventListener('click', () => {
const text = document.getElementById('text-input').value; if (!text) return;
const color = document.getElementById('text-color').value, font = document.getElementById('font-select').value,
fontSize = parseInt(document.getElementById('font-size').value, 10), shadow = document.getElementById('text-shadow').checked;
ctx.font = `${fontSize}px ${font}`;
const metrics = ctx.measureText(text);
const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
addLayer({ type: 'text', name: `${lang.textLayer} "${text.substring(0, 10)}..."`, content: text, x: 0, y: 0, width: metrics.width, height: height, color, font, fontSize, shadow, visible: true }, true);
switchTool('move');
});
applyCropBtn.addEventListener('click', applyCrop);
pasteBtn.addEventListener('click', pasteFromClipboard);
layerUpBtn.addEventListener('click', () => moveLayer(1));
layerDownBtn.addEventListener('click', () => moveLayer(-1));
layerDeleteBtn.addEventListener('click', () => { if (activeLayerIndex > -1) { layers.splice(activeLayerIndex, 1); setActiveLayer(layers.length > 0 ? 0 : -1); updateLayersList(); redrawCanvas(); updateExportPreview(); } });
exportFormatSelect.addEventListener('change', updateExportPreview);
exportQualitySlider.addEventListener('input', updateExportPreview);
exportBtn.addEventListener('click', () => {
const link = document.createElement('a');
const ext = exportFormatSelect.value.split('/')[1];
link.download = `edited-image.${ext === 'jpeg' ? 'jpg' : ext}`;
const flattenedCanvas = createFlattenedCanvas();
link.href = flattenedCanvas.toDataURL(exportFormatSelect.value, parseFloat(exportQualitySlider.value));
link.click();
});
const init = () => {
updateStaticUIText();
resizeWidthInput.value = logicalWidth; resizeHeightInput.value = logicalHeight;
const bgCanvas = document.createElement('canvas');
bgCanvas.width = logicalWidth; bgCanvas.height = logicalHeight;
bgCanvas.getContext('2d').fillStyle = 'white';
bgCanvas.getContext('2d').fillRect(0, 0, logicalWidth, logicalHeight);
addLayer({ type: 'image', name: lang.backgroundLayer, content: bgCanvas, x: 0, y: 0, width: logicalWidth, height: logicalHeight, visible: true });
updateCanvasSize();
fitToScreen();
switchTool('move');
};
window.addEventListener('resize', () => { updateCanvasSize(); fitToScreen(); });
init();
});
</script>
</body>
</html>