<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Bilderedigering</title>
<link rel="icon" href="data:image/png;base64,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">

<style>
:root {
--bg-color: #1e1e1e;
--primary-color: #2d2d2d;
--secondary-color: #3c3c3c;
--text-color: #e0e0e0;
--accent-color: #007acc;
--border-color: #4a4a4a;
--font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
body,
html {
margin: 0;
padding: 0;
width: 100%;
height: 100vh;
font-family: var(--font-family);
background-color: var(--bg-color);
color: var(--text-color);
overflow: hidden;
}
body {
display: grid;
grid-template-rows: auto 1fr;
}
.main-container {
display: flex;
overflow: hidden;
position: relative;
}
.toolbar {
background-color: var(--primary-color);
padding: 8px;
display: flex;
flex-direction: column;
gap: 10px;
width: 60px;
border-right: 1px solid var(--border-color);
align-items: center;
z-index: 5;
}
.tool-btn {
background-color: var(--secondary-color);
border: 1px solid var(--border-color);
color: var(--text-color);
cursor: pointer;
padding: 8px;
width: 42px;
height: 42px;
font-size: 20px;
border-radius: 4px;
transition: background-color 0.2s;
display: flex;
align-items: center;
justify-content: center;
}
.tool-btn:hover {
background-color: var(--accent-color);
}
.tool-btn.active {
background-color: var(--accent-color);
border: 1px solid var(--text-color);
}
.options-bar {
background-color: var(--primary-color);
padding: 5px 15px;
border-bottom: 1px solid var(--border-color);
display: flex;
align-items: center;
gap: 10px;
min-height: 40px;
flex-wrap: wrap;
position: relative;
z-index: 10;
}
.options-bar label,
.options-bar button,
.options-bar input,
.options-bar select,
.options-bar span {
margin: 0;
font-size: 13px;
align-items: center;
display: flex;
}
.options-bar input[type="number"],
.options-bar input[type="text"],
.options-bar input[type="color"],
.options-bar select {
background-color: var(--secondary-color);
color: var(--text-color);
border: 1px solid var(--border-color);
border-radius: 3px;
padding: 3px 5px;
max-width: 80px;
transition: border-color 0.2s;
}
.options-bar input#text-input {
max-width: 180px;
}
.options-bar input::placeholder {
color: #9e9e9e;
opacity: 1;
}
.options-bar input:focus,
.options-bar select:focus {
outline: none;
border-color: var(--accent-color);
}
.options-bar button {
background-color: var(--accent-color);
color: var(--text-color);
border: none;
padding: 4px 10px;
border-radius: 3px;
cursor: pointer;
}
.options-bar .separator {
width: 1px;
height: 25px;
background-color: var(--border-color);
margin: 0 5px;
}
.canvas-container {
flex: 1;
display: grid;
place-items: center;
overflow: hidden;
background-image: linear-gradient(45deg, #2a2a2a 25%, transparent 25%), linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #2a2a2a 75%), linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
background-size: 20px 20px;
background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
position: relative;
}
canvas {
box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
cursor: default;
}
.right-panel {
width: 200px;
background-color: var(--primary-color);
border-left: 1px solid var(--border-color);
display: flex;
flex-direction: column;
overflow-y: auto;
z-index: 5;
}
.panel-section {
padding: 10px;
border-bottom: 1px solid var(--border-color);
}
.panel-section h4 {
margin: 0 0 10px 0;
font-size: 14px;
border-bottom: 1px solid var(--border-color);
padding-bottom: 5px;
}
#layers-list {
list-style: none;
padding: 0;
margin: 0;
max-height: 200px;
overflow-y: auto;
}
#layers-list li {
background-color: var(--secondary-color);
padding: 8px;
margin-bottom: 5px;
cursor: pointer;
border: 1px solid transparent;
border-radius: 3px;
font-size: 13px;
display: flex;
justify-content: space-between;
align-items: center;
}
#layers-list li.active {
border: 1px solid var(--accent-color);
background-color: #4a4a4a;
}
#layers-list li .visibility-toggle {
cursor: pointer;
opacity: 0.7;
margin-right: 5px;
}
#layers-list li .visibility-toggle:hover {
opacity: 1;
}
.layer-controls {
display: flex;
gap: 5px;
margin-top: 10px;
}
.layer-controls button {
flex: 1;
padding: 5px;
font-size: 16px;
}
#export-preview {
max-width: 100%;
height: auto;
margin-top: 10px;
border: 1px solid var(--border-color);
}
#file-size-info {
font-size: 12px;
margin-top: 5px;
text-align: center;
}
#crop-info {
position: fixed;
background-color: rgba(0, 0, 0, 0.7);
color: white;
padding: 3px 6px;
font-size: 12px;
border-radius: 3px;
pointer-events: none;
display: none;
z-index: 20;
transform: translate(15px, 15px);
}
#zoom-display {
font-size: 13px;
color: var(--text-color);
min-width: 50px;
text-align: center;
}
.adjustment-slider {
width: calc(100% - 10px);
margin-bottom: 5px;
-webkit-appearance: none;
height: 4px;
background: #555;
outline: none;
opacity: 0.7;
transition: opacity .2s;
border-radius: 2px;
}
.adjustment-slider:hover {
opacity: 1;
}
.adjustment-slider::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 12px;
height: 12px;
border-radius: 50%;
background: var(--accent-color);
cursor: pointer;
}
.adjustment-slider::-moz-range-thumb {
width: 12px;
height: 12px;
border-radius: 50%;
background: var(--accent-color);
cursor: pointer;
}
.adjustment-group {
margin-bottom: 10px;
padding-bottom: 5px;
border-bottom: 1px solid var(--border-color);
}
.adjustment-group:last-child {
border-bottom: none;
margin-bottom: 0;
}
.adjustment-group label {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 3px;
font-size: 12px;
}
.adjustment-group input[type="range"] + span {
font-size: 11px;
min-width: 25px;
text-align: right;
}
</style>
</head>
<body>
<input type="file" id="file-input" accept="image/*" style="display: none;">
<input type="file" id="project-input" accept=".json" style="display: none;">
<div class="options-bar">
<button id="open-btn"></button>
<button id="import-btn"></button>
<button id="paste-btn"></button>
<div class="separator"></div>
<button id="save-project-btn"></button>
<button id="load-project-btn"></button>
<div class="separator"></div>
<button id="flatten-btn"></button>
<div class="separator"></div>
<label for="resize-width" id="width-label"></label>
<input type="number" id="resize-width" min="1">
<label for="resize-height" id="height-label"></label>
<input type="number" id="resize-height" min="1">
<label id="keep-proportions-label"><input type="checkbox" id="keep-proportions" checked=""> 🔗</label>
<button id="resize-btn"></button>
<div class="separator"></div>
<button id="zoom-out-btn" title="Zoom ut">-</button>
<button id="fit-to-screen-btn" title="Tilpass skjerm">[ ]</button>
<button id="zoom-in-btn" title="Zoom inn">+</button>
<span id="zoom-display">100%</span>
<div class="separator"></div>
<div id="crop-options" style="display: none; align-items: center; gap: 10px;">
<button id="apply-crop-btn"></button>
</div>
<div id="text-options" style="display: none; align-items: center; gap: 15px;">
<input type="text" id="text-input" placeholder="Skriv tekst her...">
<input type="color" id="text-color" value="#000000">
<select id="font-select">
<option>Arial</option>
<option>Verdana</option>
<option>Times New Roman</option>
<option>Courier New</option>
<option>Impact</option>
</select>
<input type="number" id="font-size" value="48" min="1">
<button id="add-text-btn"></button>
<div class="separator"></div>
<label><input type="checkbox" id="text-shadow"> <span id="shadow-label"></span></label>
</div>
</div>
<div class="main-container">
<div class="toolbar">
<button class="tool-btn active" id="tool-move" title="Flytt (V)">V</button>
<button class="tool-btn" id="tool-crop" title="Beskjær (C)">C</button>
<button class="tool-btn" id="tool-text" title="Tekst (T)">T</button>
</div>
<div class="canvas-container" id="canvas-container">
<canvas id="canvas"></canvas>
<div id="crop-info"></div>
</div>
<div class="right-panel">
<div class="panel-section">
<h4 id="layers-title"></h4>
<ul id="layers-list"></ul>
<div class="layer-controls">
<button id="layer-up-btn" title="Flytt laget opp">▲</button>
<button id="layer-down-btn" title="Flytt laget ned">▼</button>
<button id="layer-duplicate-btn" title="Dupliser lag">📋</button>
<button id="layer-delete-btn" title="Slett lag">🗑️</button>
</div>
<div style="margin-top: 10px; display: flex; align-items: center; gap: 5px;">
<label for="layer-opacity" style="flex: 0 0 auto;"></label>
<input type="range" id="layer-opacity" class="adjustment-slider" min="0" max="1" step="0.01" value="1">
<span id="layer-opacity-value">100%</span>
</div>
<div style="margin-top: 5px; display: flex; align-items: center; gap: 5px;">
<label for="layer-blend-mode" style="flex: 0 0 auto;"></label>
<select id="layer-blend-mode">
<option value="source-over">Normal</option>
<option value="multiply">Multipliser</option>
<option value="screen">Raster</option>
<option value="overlay">Overlegg</option>
<option value="darken">Gjør mørkere</option>
<option value="lighten">Gjør lysere</option>
<option value="color-dodge">Farge-dodge</option>
<option value="color-burn">Farge-burn</option>
<option value="hard-light">Hardt lys</option>
<option value="soft-light">Bløtt lys</option>
<option value="difference">Differanse</option>
<option value="exclusion">Ekskludering</option>
<option value="hue">Fargetone</option>
<option value="saturation">Metning</option>
<option value="color">Farge</option>
<option value="luminosity">Luminans</option>
</select>
</div>
</div>
<div class="panel-section" id="adjustments-panel" style="display: none;">
<h4 id="adjustments-title"></h4>
<div class="adjustment-group">
<label for="adj-brightness">Lysstyrke: <span id="brightness-value">0</span></label>
<input type="range" id="adj-brightness" class="adjustment-slider" min="-100" max="100" value="0">
</div>
<div class="adjustment-group">
<label for="adj-contrast">Kontrast: <span id="contrast-value">0</span></label>
<input type="range" id="adj-contrast" class="adjustment-slider" min="-100" max="100" value="0">
</div>
<div class="adjustment-group">
<label for="adj-saturation">Metning: <span id="saturation-value">0</span></label>
<input type="range" id="adj-saturation" class="adjustment-slider" min="-100" max="100" value="0">
</div>
<div class="adjustment-group">
<label for="adj-hue">Fargetone: <span id="hue-value">0</span></label>
<input type="range" id="adj-hue" class="adjustment-slider" min="0" max="360" value="0">
</div>
<div class="adjustment-group">
<label for="adj-sepia">Sepia: <span id="sepia-value">0%</span></label>
<input type="range" id="adj-sepia" class="adjustment-slider" min="0" max="100" value="0">
</div>
<div class="adjustment-group">
<label for="adj-grayscale">Gråtoner: <span id="grayscale-value">0%</span></label>
<input type="range" id="adj-grayscale" class="adjustment-slider" min="0" max="100" value="0">
</div>
<div class="adjustment-group">
<label for="adj-invert">Inverter: <span id="invert-value">0%</span></label>
<input type="range" id="adj-invert" class="adjustment-slider" min="0" max="100" value="0">
</div>
</div>
<div class="panel-section" id="filters-panel" style="display: none;">
<h4 id="filters-title"></h4>
<div class="adjustment-group">
<label for="filter-blur">Uskarphet (px): <span id="blur-value">0</span></label>
<input type="range" id="filter-blur" class="adjustment-slider" min="0" max="20" step="0.1" value="0">
</div>
<div class="adjustment-group">
<button id="filter-sharpen" style="width: 100%; margin-bottom: 5px;"></button>
<button id="filter-emboss" style="width: 100%;"></button>
</div>
</div>
<div class="panel-section">
<h4 id="export-title"></h4>
<label for="export-format" id="format-label"></label>
<select id="export-format">
<option value="image/png">PNG</option>
<option value="image/jpeg">JPEG</option>
<option value="image/webp">WEBP</option>
</select>
<div id="quality-control" style="display:none; margin-top: 10px;">
<label for="export-quality" id="quality-label"></label>
<input type="range" id="export-quality" min="0.1" max="1" step="0.1" value="0.9">
</div>
<img id="export-preview" src="" alt="Forhåndsvisning">
<div id="file-size-info"></div>
<div id="export-note-text" style="font-size: 11px; color: #888; margin-top: 5px;"></div>
<button id="export-btn" style="width: 100%; margin-top: 10px;"></button>
</div>
</div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
const lang = {
open: "Åpne",
importImage: "Importer",
paste: "Lim inn",
saveProject: "Lagre prosjekt",
loadProject: "Last inn prosjekt",
flatten: "Slå sammen lag",
openTitle: "Åpne bilde (erstatter lerret)",
importTitle: "Importer bilde som nytt lag",
pasteTitle: "Lim inn bilde fra utklippstavle",
saveProjectTitle: "Lagre prosjektfil (.json)",
loadProjectTitle: "Last inn prosjektfil (.json)",
flattenTitle: "Slå sammen alle synlige lag til ett",
width: "Bredde:",
height: "Høyde:",
keepAspectRatio: "Behold sideforhold",
resize: "Endre størrelse",
zoomOut: "Zoom ut",
fitToScreen: "Tilpass skjerm",
zoomIn: "Zoom inn",
applyCrop: "Bruk beskjæring",
textInputPlaceholder: "Skriv tekst her...",
addText: "Legg til tekst",
shadow: "Skygge",
toolMove: "Flytt (V)",
toolCrop: "Beskjær (C)",
toolText: "Tekst (T)",
layers: "Lag",
layerOpacity: "Opasitet:",
layerBlendMode: "Blandingsmodus:",
moveUp: "Flytt opp",
moveDown: "Flytt ned",
delete: "Slett",
showHideLayer: "Vis/skjul lag",
duplicateLayer: "Dupliser lag",
adjustments: "Justeringer",
filters: "Filtre",
brightness: "Lysstyrke:",
contrast: "Kontrast:",
saturation: "Metning:",
hue: "Fargetone:",
sepia: "Sepia:",
grayscale: "Gråtoner:",
invert: "Inverter:",
blur: "Uskarphet (px):",
sharpen: "Gjør skarpere",
emboss: "Relieff",
exportTitle: "Eksporter",
exportImage: "Eksporter bilde",
format: "Format:",
quality: "Kvalitet:",
previewAlt: "Forhåndsvisning",
fileSize: "Størrelse:",
exportNote: "Merk: Det eksporterte bildet er slått sammen.",
pastedImage: "Innlimt bilde",
croppedImage: "Beskåret bilde",
resizedImage: "Endret størrelse",
textLayer: "Tekst:",
backgroundLayer: "Bakgrunn",
flattenedImage: "Sammenslått bilde",
cropConfirm: "Beskjæring vil slå sammen alle lag til ett. Vil du fortsette?",
resizeConfirm: "Størrelsesendring vil slå sammen alle lag til ett. Vil du fortsette?",
flattenConfirm: "Dette vil slå sammen alle synlige lag til ett. Fortsette?",
invalidSize: "Ugyldig bredde/høyde.",
noImageOnClipboard: "Fant ikke noe bilde på utklippstavlen.",
pasteError: "Kunne ikke lime inn. Sjekk konsollen for feilmelding.",
clipboardDenied: "Tilgang til utklippstavlen ble nektet.",
projectLoadError: "Kunne ikke laste prosjektet. Sørg for at det er en gyldig .json-fil.",
};
const CONSTANTS = {
TOOLS: { MOVE: 'move', CROP: 'crop', TEXT: 'text' },
PAN_BUTTON: 1,
DEFAULT_CANVAS_WIDTH: 800,
DEFAULT_CANVAS_HEIGHT: 600,
ADJUSTMENT_DEFAULTS: {
brightness: 0, contrast: 0, saturation: 0, hue: 0,
sepia: 0, grayscale: 0, invert: 0, blur: 0
},
};
const state = {
layers: [],
activeLayerIndex: -1,
currentTool: CONSTANTS.TOOLS.MOVE,
logicalWidth: CONSTANTS.DEFAULT_CANVAS_WIDTH,
logicalHeight: CONSTANTS.DEFAULT_CANVAS_HEIGHT,
currentAspectRatio: CONSTANTS.DEFAULT_CANVAS_WIDTH / CONSTANTS.DEFAULT_CANVAS_HEIGHT,
zoom: 1.0,
panX: 0,
panY: 0,
mouse: {
isDown: false,
startX: 0, startY: 0,
dragOffsetX: 0, dragOffsetY: 0,
originalLayerState: null,
activeHandle: null,
},
status: {
isDragging: false, isCropping: false, isPanning: false,
isResizingLayer: false, isMovingCrop: false, isResizingCrop: false,
},
cropRect: { x: 0, y: 0, w: 0, h: 0 },
};
// =================================================================================
// SECTION: DOM Element Cache
// =================================================================================
const DOM = {
canvas: document.getElementById('canvas'),
canvasContainer: document.getElementById('canvas-container'),
ctx: null, // Initialized in init
fileInput: document.getElementById('file-input'),
projectInput: document.getElementById('project-input'),
openBtn: document.getElementById('open-btn'),
importBtn: document.getElementById('import-btn'),
pasteBtn: document.getElementById('paste-btn'),
saveProjectBtn: document.getElementById('save-project-btn'),
loadProjectBtn: document.getElementById('load-project-btn'),
flattenBtn: document.getElementById('flatten-btn'),
zoomInBtn: document.getElementById('zoom-in-btn'),
zoomOutBtn: document.getElementById('zoom-out-btn'),
fitToScreenBtn: document.getElementById('fit-to-screen-btn'),
zoomDisplay: document.getElementById('zoom-display'),
layersList: document.getElementById('layers-list'),
layerOpacitySlider: document.getElementById('layer-opacity'),
layerOpacityValue: document.getElementById('layer-opacity-value'),
layerBlendModeSelect: document.getElementById('layer-blend-mode'),
layerUpBtn: document.getElementById('layer-up-btn'),
layerDownBtn: document.getElementById('layer-down-btn'),
layerDuplicateBtn: document.getElementById('layer-duplicate-btn'),
layerDeleteBtn: document.getElementById('layer-delete-btn'),
textOptions: document.getElementById('text-options'),
addTextBtn: document.getElementById('add-text-btn'),
textInput: document.getElementById('text-input'),
textColorInput: document.getElementById('text-color'),
fontSelect: document.getElementById('font-select'),
fontSizeInput: document.getElementById('font-size'),
textShadowCheckbox: document.getElementById('text-shadow'),
cropOptions: document.getElementById('crop-options'),
applyCropBtn: document.getElementById('apply-crop-btn'),
cropInfo: document.getElementById('crop-info'),
resizeWidthInput: document.getElementById('resize-width'),
resizeHeightInput: document.getElementById('resize-height'),
resizeBtn: document.getElementById('resize-btn'),
keepProportionsCheckbox: document.getElementById('keep-proportions'),
toolMoveBtn: document.getElementById('tool-move'),
toolCropBtn: document.getElementById('tool-crop'),
toolTextBtn: document.getElementById('tool-text'),
adjustmentsPanel: document.getElementById('adjustments-panel'),
adjBrightness: document.getElementById('adj-brightness'),
brightnessValue: document.getElementById('brightness-value'),
adjContrast: document.getElementById('adj-contrast'),
contrastValue: document.getElementById('contrast-value'),
adjSaturation: document.getElementById('adj-saturation'),
saturationValue: document.getElementById('saturation-value'),
adjHue: document.getElementById('adj-hue'),
hueValue: document.getElementById('hue-value'),
adjSepia: document.getElementById('adj-sepia'),
sepiaValue: document.getElementById('sepia-value'),
adjGrayscale: document.getElementById('adj-grayscale'),
grayscaleValue: document.getElementById('grayscale-value'),
adjInvert: document.getElementById('adj-invert'),
invertValue: document.getElementById('invert-value'),
filtersPanel: document.getElementById('filters-panel'),
filterBlur: document.getElementById('filter-blur'),
blurValue: document.getElementById('blur-value'),
filterSharpenBtn: document.getElementById('filter-sharpen'),
filterEmbossBtn: document.getElementById('filter-emboss'),
exportFormatSelect: document.getElementById('export-format'),
qualityControl: document.getElementById('quality-control'),
exportQualitySlider: document.getElementById('export-quality'),
exportPreview: document.getElementById('export-preview'),
fileSizeInfo: document.getElementById('file-size-info'),
exportBtn: document.getElementById('export-btn'),
};
DOM.ctx = DOM.canvas.getContext('2d');
// =================================================================================
// SECTION: UI & Text Updates
// =================================================================================
function updateStaticUIText() {
DOM.openBtn.textContent = lang.open;
DOM.openBtn.title = lang.openTitle;
DOM.importBtn.textContent = lang.importImage;
DOM.importBtn.title = lang.importTitle;
DOM.pasteBtn.textContent = lang.paste;
DOM.pasteBtn.title = lang.pasteTitle;
DOM.saveProjectBtn.textContent = lang.saveProject;
DOM.saveProjectBtn.title = lang.saveProjectTitle;
DOM.loadProjectBtn.textContent = lang.loadProject;
DOM.loadProjectBtn.title = lang.loadProjectTitle;
DOM.flattenBtn.textContent = lang.flatten;
DOM.flattenBtn.title = lang.flattenTitle;
document.getElementById('width-label').textContent = lang.width;
document.getElementById('height-label').textContent = lang.height;
document.getElementById('keep-proportions-label').title = lang.keepAspectRatio;
DOM.resizeBtn.textContent = lang.resize;
DOM.applyCropBtn.textContent = lang.applyCrop;
DOM.textInput.placeholder = lang.textInputPlaceholder;
DOM.addTextBtn.textContent = lang.addText;
document.getElementById('shadow-label').textContent = lang.shadow;
document.getElementById('layers-title').textContent = lang.layers;
document.getElementById('layer-opacity').previousElementSibling.textContent = lang.layerOpacity;
document.getElementById('layer-blend-mode').previousElementSibling.textContent = lang.layerBlendMode;
DOM.layerUpBtn.title = lang.moveUp;
DOM.layerDownBtn.title = lang.moveDown;
DOM.layerDuplicateBtn.title = lang.duplicateLayer;
DOM.layerDeleteBtn.title = lang.delete;
document.getElementById('adjustments-title').textContent = lang.adjustments;
document.getElementById('adj-brightness').previousElementSibling.childNodes[0].nodeValue = lang.brightness + ' ';
document.getElementById('adj-contrast').previousElementSibling.childNodes[0].nodeValue = lang.contrast + ' ';
document.getElementById('adj-saturation').previousElementSibling.childNodes[0].nodeValue = lang.saturation + ' ';
document.getElementById('adj-hue').previousElementSibling.childNodes[0].nodeValue = lang.hue + ' ';
document.getElementById('adj-sepia').previousElementSibling.childNodes[0].nodeValue = lang.sepia + ' ';
document.getElementById('adj-grayscale').previousElementSibling.childNodes[0].nodeValue = lang.grayscale + ' ';
document.getElementById('adj-invert').previousElementSibling.childNodes[0].nodeValue = lang.invert + ' ';
document.getElementById('filters-title').textContent = lang.filters;
document.getElementById('filter-blur').previousElementSibling.childNodes[0].nodeValue = lang.blur + ' ';
DOM.filterSharpenBtn.textContent = lang.sharpen;
DOM.filterEmbossBtn.textContent = lang.emboss;
document.getElementById('export-title').textContent = lang.exportTitle;
DOM.exportBtn.textContent = lang.exportImage;
document.getElementById('format-label').textContent = lang.format;
document.getElementById('quality-label').textContent = lang.quality;
DOM.exportPreview.alt = lang.previewAlt;
document.getElementById('export-note-text').textContent = lang.exportNote;
}
// =================================================================================
// SECTION: Unified Drawing Logic (Refactored)
// =================================================================================
const drawAllLayers = (targetCtx) => {
state.layers.forEach(layer => {
if (!layer.visible) return;
const tempCanvas = document.createElement('canvas');
tempCanvas.width = layer.width;
tempCanvas.height = layer.height;
const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
tempCtx.save();
if (layer.type === 'image') {
tempCtx.drawImage(layer.content, 0, 0, layer.width, layer.height);
} else if (layer.type === 'text') {
tempCtx.font = `${layer.fontSize}px ${layer.font}`;
tempCtx.fillStyle = layer.color;
if (layer.shadow) {
tempCtx.shadowColor = 'rgba(0,0,0,0.5)';
tempCtx.shadowBlur = 5;
tempCtx.shadowOffsetX = 3;
tempCtx.shadowOffsetY = 3;
}
tempCtx.textBaseline = 'top';
tempCtx.fillText(layer.content, 0, 0);
}
tempCtx.restore();
const filters = [];
if (layer.adjustments.brightness !== 0) filters.push(`brightness(${100 + layer.adjustments.brightness}%)`);
if (layer.adjustments.contrast !== 0) filters.push(`contrast(${100 + layer.adjustments.contrast}%)`);
if (layer.adjustments.saturation !== 0) filters.push(`saturate(${100 + layer.adjustments.saturation}%)`);
if (layer.adjustments.hue !== 0) filters.push(`hue-rotate(${layer.adjustments.hue}deg)`);
if (layer.adjustments.sepia !== 0) filters.push(`sepia(${layer.adjustments.sepia}%)`);
if (layer.adjustments.grayscale !== 0) filters.push(`grayscale(${layer.adjustments.grayscale}%)`);
if (layer.adjustments.invert !== 0) filters.push(`invert(${layer.adjustments.invert}%)`);
if (layer.adjustments.blur > 0) filters.push(`blur(${layer.adjustments.blur}px)`);
if (filters.length > 0) {
tempCtx.filter = filters.join(' ');
tempCtx.drawImage(tempCanvas, 0, 0);
tempCtx.filter = 'none';
}
if (layer.filterApplied) {
const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
if (layer.filterApplied === 'sharpen') applyConvolutionFilter(imageData, 'sharpen');
if (layer.filterApplied === 'emboss') applyConvolutionFilter(imageData, 'emboss');
tempCtx.putImageData(imageData, 0, 0);
}
targetCtx.globalAlpha = layer.opacity;
targetCtx.globalCompositeOperation = layer.blendMode;
targetCtx.drawImage(tempCanvas, layer.x, layer.y, layer.width, layer.height);
targetCtx.globalAlpha = 1.0;
targetCtx.globalCompositeOperation = 'source-over';
tempCanvas.width = tempCanvas.height = 0;
});
};
// =================================================================================
// SECTION: Canvas & Drawing
// =================================================================================
const updateCanvasSize = () => {
const rect = DOM.canvasContainer.getBoundingClientRect();
DOM.canvas.style.width = `${rect.width}px`;
DOM.canvas.style.height = `${rect.height}px`;
const dpr = window.devicePixelRatio || 1;
DOM.canvas.width = rect.width * dpr;
DOM.canvas.height = rect.height * dpr;
DOM.ctx.scale(dpr, dpr);
redrawCanvas();
};
const applyConvolutionFilter = (imageData, filterType) => {
const weights = {
sharpen: [0, -1, 0, -1, 5, -1, 0, -1, 0],
emboss: [-2, -1, 0, -1, 1, 1, 0, 1, 2]
}[filterType];
const opacity = 1;
const offset = filterType === 'emboss' ? 128 : 0;
const pixels = imageData.data;
const width = imageData.width;
const height = imageData.height;
const output = new Uint8ClampedArray(pixels.length);
const side = Math.round(Math.sqrt(weights.length));
const halfSide = Math.floor(side / 2);
for (let y = 0; y < height; y++) {
for (let x = 0; x < width; x++) {
const dstOff = (y * width + x) * 4;
let r = 0, g = 0, b = 0;
for (let cy = 0; cy < side; cy++) {
for (let cx = 0; cx < side; cx++) {
const scy = y + cy - halfSide;
const scx = x + cx - halfSide;
if (scy >= 0 && scy < height && scx >= 0 && scx < width) {
const srcOff = (scy * width + scx) * 4;
const wt = weights[cy * side + cx];
r += pixels[srcOff] * wt;
g += pixels[srcOff + 1] * wt;
b += pixels[srcOff + 2] * wt;
}
}
}
output[dstOff] = Math.min(255, Math.max(0, r * opacity + offset));
output[dstOff + 1] = Math.min(255, Math.max(0, g * opacity + offset));
output[dstOff + 2] = Math.min(255, Math.max(0, b * opacity + offset));
output[dstOff + 3] = pixels[dstOff + 3];
}
}
for (let i = 0; i < pixels.length; i++) {
pixels[i] = output[i];
}
};
const redrawCanvas = () => {
const dpr = window.devicePixelRatio || 1;
const ctx = DOM.ctx;
ctx.save();
ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
ctx.clearRect(0, 0, DOM.canvas.width, DOM.canvas.height);
const viewWidth = DOM.canvas.width / dpr;
const viewHeight = DOM.canvas.height / dpr;
ctx.translate(viewWidth / 2 + state.panX, viewHeight / 2 + state.panY);
ctx.scale(state.zoom, state.zoom);
ctx.translate(-state.logicalWidth / 2, -state.logicalHeight / 2);
drawCheckerboard(ctx, 0, 0, state.logicalWidth, state.logicalHeight, 20);
drawAllLayers(ctx);
if (state.activeLayerIndex !== -1 && state.layers[state.activeLayerIndex]?.visible && state.currentTool === CONSTANTS.TOOLS.MOVE) {
const layer = state.layers[state.activeLayerIndex];
ctx.strokeStyle = 'rgba(0, 122, 204, 0.8)';
ctx.lineWidth = 2 / state.zoom;
ctx.strokeRect(layer.x, layer.y, layer.width, layer.height);
drawHandles(getHandles({ x: layer.x, y: layer.y, w: layer.width, h: layer.height }));
}
if (state.currentTool === CONSTANTS.TOOLS.CROP && state.cropRect.w !== 0 && state.cropRect.h !== 0) {
const normCrop = getNormalizedRect(state.cropRect);
ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
ctx.beginPath();
ctx.rect(normCrop.x, normCrop.y, normCrop.w, normCrop.h);
ctx.rect(0, 0, state.logicalWidth, state.logicalHeight);
ctx.closePath();
ctx.fill('evenodd');
ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
ctx.lineWidth = 1 / state.zoom;
ctx.strokeRect(normCrop.x, normCrop.y, normCrop.w, normCrop.h);
drawHandles(getHandles(normCrop));
}
ctx.restore();
};
const drawCheckerboard = (ctx, x, y, width, height, size) => {
const light = '#454545';
const dark = '#3c3c3c';
for (let i = 0; i < Math.ceil(width / size); i++) {
for (let j = 0; j < Math.ceil(height / size); j++) {
ctx.fillStyle = (i + j) % 2 === 0 ? light : dark;
ctx.fillRect(x + i * size, y + j * size, size, size);
}
}
};
const drawHandles = (handles) => {
const ctx = DOM.ctx;
const handleSize = 8 / state.zoom;
ctx.fillStyle = 'white';
ctx.strokeStyle = 'black';
ctx.lineWidth = 1 / state.zoom;
for (const handle in handles) {
const pos = handles[handle];
ctx.fillRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
ctx.strokeRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
}
};
const getHandles = (rect) => {
const { x, y, w, h } = rect;
return {
topLeft: { x, y }, topMiddle: { x: x + w / 2, y }, topRight: { x: x + w, y },
middleLeft: { x, y: y + h / 2 }, middleRight: { x: x + w, y: y + h / 2 },
bottomLeft: { x, y: y + h }, bottomMiddle: { x: x + w / 2, y: y + h }, bottomRight: { x: x + w, y: y + h },
};
};
const getCursorForHandle = (handleName) => {
switch (handleName) {
case 'topLeft': case 'bottomRight': return 'nwse-resize';
case 'topRight': case 'bottomLeft': return 'nesw-resize';
case 'topMiddle': case 'bottomMiddle': return 'ns-resize';
case 'middleLeft': case 'middleRight': return 'ew-resize';
default: return 'grab';
}
};
const getNormalizedRect = (rect) => ({
x: rect.w < 0 ? rect.x + rect.w : rect.x,
y: rect.h < 0 ? rect.y + rect.h : rect.y,
w: Math.abs(rect.w),
h: Math.abs(rect.h),
});
const getMousePos = (e) => {
const rect = DOM.canvas.getBoundingClientRect();
const viewWidth = rect.width;
const viewHeight = rect.height;
const mouseX = e.clientX - rect.left;
const mouseY = e.clientY - rect.top;
const worldX = (mouseX - viewWidth / 2 - state.panX) / state.zoom + state.logicalWidth / 2;
const worldY = (mouseY - viewHeight / 2 - state.panY) / state.zoom + state.logicalHeight / 2;
return { x: worldX, y: worldY };
};
const fitToScreen = () => {
const rect = DOM.canvasContainer.getBoundingClientRect();
const padding = 40;
const availableWidth = rect.width - padding;
const availableHeight = rect.height - padding;
const scale = Math.min(availableWidth / state.logicalWidth, availableHeight / state.logicalHeight);
state.zoom = scale;
state.panX = 0;
state.panY = 0;
DOM.zoomDisplay.textContent = `${(state.zoom * 100).toFixed(0)}%`;
redrawCanvas();
};
const doZoom = (delta, centerX, centerY) => {
const rect = DOM.canvas.getBoundingClientRect();
const viewWidth = rect.width;
const viewHeight = rect.height;
const mouseX = centerX ?? viewWidth / 2;
const mouseY = centerY ?? viewHeight / 2;
const worldX_before = (mouseX - viewWidth / 2 - state.panX) / state.zoom + state.logicalWidth / 2;
const worldY_before = (mouseY - viewHeight / 2 - state.panY) / state.zoom + state.logicalHeight / 2;
const oldZoom = state.zoom;
state.zoom = Math.max(0.02, Math.min(32, state.zoom * (1 + delta)));
state.panX += (worldX_before - state.logicalWidth / 2) * (oldZoom - state.zoom);
state.panY += (worldY_before - state.logicalHeight / 2) * (oldZoom - state.zoom);
DOM.zoomDisplay.textContent = `${(state.zoom * 100).toFixed(0)}%`;
redrawCanvas();
};
const createFlattenedCanvas = () => {
const tempCanvas = document.createElement('canvas');
tempCanvas.width = state.logicalWidth;
tempCanvas.height = state.logicalHeight;
const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
const bgCanvas = document.createElement('canvas');
bgCanvas.width = state.logicalWidth;
bgCanvas.height = state.logicalHeight;
const bgCtx = bgCanvas.getContext('2d');
bgCtx.fillStyle = 'white';
bgCtx.fillRect(0,0,state.logicalWidth,state.logicalHeight);
tempCtx.drawImage(bgCanvas, 0, 0);
drawAllLayers(tempCtx);
return tempCanvas;
};
const updateLayersList = () => {
DOM.layersList.innerHTML = '';
[...state.layers].reverse().forEach((layer, index) => {
const originalIndex = state.layers.length - 1 - index;
const li = document.createElement('li');
li.textContent = `${layer.name}`;
li.dataset.index = originalIndex;
if (originalIndex === state.activeLayerIndex) li.classList.add('active');
const visibilityToggle = document.createElement('span');
visibilityToggle.className = 'visibility-toggle';
visibilityToggle.innerHTML = layer.visible ? '👁️' : '🙈';
visibilityToggle.title = lang.showHideLayer;
visibilityToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleLayerVisibility(originalIndex); });
li.prepend(visibilityToggle);
li.addEventListener('click', () => setActiveLayer(originalIndex));
DOM.layersList.appendChild(li);
});
updateAdjustmentPanelsVisibility();
updateAdjustmentPanelValues();
};
const toggleLayerVisibility = (index) => {
state.layers[index].visible = !state.layers[index].visible;
redrawCanvas();
updateLayersList();
updateExportPreview();
};
const setActiveLayer = (index) => {
state.activeLayerIndex = index;
updateLayersList();
redrawCanvas();
};
const addLayer = (layer, center = false) => {
layer.opacity = layer.opacity ?? 1.0;
layer.blendMode = layer.blendMode ?? 'source-over';
layer.adjustments = layer.adjustments ?? { ...CONSTANTS.ADJUSTMENT_DEFAULTS };
layer.filterApplied = layer.filterApplied ?? null;
layer.visible = layer.visible ?? true;
if (center) {
layer.x = (state.logicalWidth - layer.width) / 2;
layer.y = (state.logicalHeight - layer.height) / 2;
}
state.layers.push(layer);
setActiveLayer(state.layers.length - 1);
updateExportPreview();
};
const moveLayer = (direction) => {
if (state.activeLayerIndex < 0) return;
const newIndex = state.activeLayerIndex + direction;
if (newIndex < 0 || newIndex >= state.layers.length) return;
[state.layers[state.activeLayerIndex], state.layers[newIndex]] =
[state.layers[newIndex], state.layers[state.activeLayerIndex]];
setActiveLayer(newIndex);
updateExportPreview();
};
const duplicateActiveLayer = () => {
if (state.activeLayerIndex < 0) return;
const originalLayer = state.layers[state.activeLayerIndex];
let newContent;
if (originalLayer.type === 'image') {
newContent = new Image();
newContent.src = originalLayer.content.src;
newContent.onload = () => {
addLayer({
...originalLayer,
name: `${originalLayer.name} (kopi)`,
content: newContent,
x: originalLayer.x + 10,
y: originalLayer.y + 10,
});
};
} else if (originalLayer.type === 'text') {
newContent = originalLayer.content;
addLayer({
...originalLayer,
name: `${originalLayer.name} (kopi)`,
x: originalLayer.x + 10,
y: originalLayer.y + 10,
content: newContent,
});
}
};
const deleteActiveLayer = () => {
if (state.activeLayerIndex > -1) {
state.layers.splice(state.activeLayerIndex, 1);
setActiveLayer(state.layers.length > 0 ? Math.min(state.activeLayerIndex, state.layers.length - 1) : -1);
updateLayersList();
redrawCanvas();
updateExportPreview();
}
};
const switchTool = (tool) => {
if (document.querySelector('.tool-btn.active')) {
document.querySelector('.tool-btn.active').classList.remove('active');
}
document.getElementById(`tool-${tool}`).classList.add('active');
state.currentTool = tool;
DOM.textOptions.style.display = tool === CONSTANTS.TOOLS.TEXT ? 'flex' : 'none';
DOM.cropOptions.style.display = 'none';
if (tool !== CONSTANTS.TOOLS.CROP) {
state.cropRect = { x: 0, y: 0, w: 0, h: 0 };
} else if (tool === CONSTANTS.TOOLS.CROP && state.cropRect.w !== 0) {
DOM.cropOptions.style.display = 'flex';
}
DOM.canvas.style.cursor = tool === CONSTANTS.TOOLS.CROP ? 'crosshair' : (tool === CONSTANTS.TOOLS.MOVE ? 'grab' : 'default');
redrawCanvas();
};
const updateExportPreview = () => {
const tempCanvas = createFlattenedCanvas();
const format = DOM.exportFormatSelect.value;
const quality = parseFloat(DOM.exportQualitySlider.value);
DOM.qualityControl.style.display = ['image/jpeg', 'image/webp'].includes(format) ? 'block' : 'none';
tempCanvas.toBlob(blob => {
if (blob) {
if (DOM.exportPreview.src) URL.revokeObjectURL(DOM.exportPreview.src);
const url = URL.createObjectURL(blob);
DOM.exportPreview.src = url;
DOM.fileSizeInfo.textContent = `${lang.fileSize} ${(blob.size / 1024).toFixed(2)} KB`;
} else {
DOM.fileSizeInfo.textContent = `${lang.fileSize} N/A`;
}
}, format, quality);
};
const applyCrop = () => {
if (Math.abs(state.cropRect.w) < 1 || Math.abs(state.cropRect.h) < 1) return;
if (!confirm(lang.cropConfirm)) return;
const normCrop = getNormalizedRect(state.cropRect);
const newWidth = Math.round(normCrop.w);
const newHeight = Math.round(normCrop.h);
const flattenedCanvas = createFlattenedCanvas();
const tempCanvas = document.createElement('canvas');
tempCanvas.width = newWidth;
tempCanvas.height = newHeight;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.drawImage(flattenedCanvas, normCrop.x, normCrop.y, normCrop.w, normCrop.h, 0, 0, newWidth, newHeight);
state.logicalWidth = newWidth;
state.logicalHeight = newHeight;
state.currentAspectRatio = newWidth / newHeight;
DOM.resizeWidthInput.value = newWidth;
DOM.resizeHeightInput.value = newHeight;
const newImg = new Image();
newImg.onload = () => {
state.layers = [{
type: 'image', name: lang.croppedImage, content: newImg,
x: 0, y: 0, width: newWidth, height: newHeight, visible: true,
opacity: 1.0, blendMode: 'source-over', adjustments: { ...CONSTANTS.ADJUSTMENT_DEFAULTS }, filterApplied: null
}];
setActiveLayer(0);
switchTool(CONSTANTS.TOOLS.MOVE);
fitToScreen();
};
newImg.src = tempCanvas.toDataURL();
};
const pasteFromClipboard = async () => {
try {
const permission = await navigator.permissions.query({ name: 'clipboard-read' });
if (permission.state === 'denied') { throw new Error(lang.clipboardDenied); }
const clipboardItems = await navigator.clipboard.read();
for (const item of clipboardItems) {
const imageType = item.types.find(type => type.startsWith('image/'));
if (imageType) {
const blob = await item.getType(imageType);
const img = new Image();
img.onload = () => {
addLayer({
type: 'image', name: lang.pastedImage, content: img,
x: 0, y: 0, width: img.width, height: img.height, visible: true
}, true);
URL.revokeObjectURL(img.src);
};
img.src = URL.createObjectURL(blob);
return;
}
}
alert(lang.noImageOnClipboard);
} catch (err) {
console.error('Kunne ikke lime inn fra utklippstavlen:', err);
alert(lang.pasteError);
}
};
const loadImageToLayer = (img, fileName, replaceAll = false) => {
if (replaceAll) {
state.logicalWidth = img.width;
state.logicalHeight = img.height;
state.currentAspectRatio = state.logicalWidth / state.logicalHeight;
DOM.resizeWidthInput.value = img.width;
DOM.resizeHeightInput.value = img.height;
state.layers = [{
type: 'image', name: fileName, content: img,
x: 0, y: 0, width: img.width, height: img.height, visible: true,
opacity: 1.0, blendMode: 'source-over', adjustments: { ...CONSTANTS.ADJUSTMENT_DEFAULTS }, filterApplied: null
}];
setActiveLayer(0);
} else {
addLayer({
type: 'image', name: fileName, content: img,
x: 0, y: 0, width: img.width, height: img.height, visible: true
}, true);
}
fitToScreen();
updateExportPreview();
};
const updateAdjustmentPanelsVisibility = () => {
const activeLayer = state.layers[state.activeLayerIndex];
const isImageLayer = activeLayer && activeLayer.type === 'image';
DOM.adjustmentsPanel.style.display = isImageLayer ? 'block' : 'none';
DOM.filtersPanel.style.display = isImageLayer ? 'block' : 'none';
};
const updateAdjustmentPanelValues = () => {
const activeLayer = state.layers[state.activeLayerIndex];
if (activeLayer) {
DOM.layerOpacitySlider.value = activeLayer.opacity;
DOM.layerOpacityValue.textContent = `${Math.round(activeLayer.opacity * 100)}%`;
DOM.layerBlendModeSelect.value = activeLayer.blendMode;
if (activeLayer.type === 'image') {
DOM.adjBrightness.value = activeLayer.adjustments.brightness;
DOM.brightnessValue.textContent = activeLayer.adjustments.brightness;
DOM.adjContrast.value = activeLayer.adjustments.contrast;
DOM.contrastValue.textContent = activeLayer.adjustments.contrast;
DOM.adjSaturation.value = activeLayer.adjustments.saturation;
DOM.saturationValue.textContent = activeLayer.adjustments.saturation;
DOM.adjHue.value = activeLayer.adjustments.hue;
DOM.hueValue.textContent = activeLayer.adjustments.hue;
DOM.adjSepia.value = activeLayer.adjustments.sepia;
DOM.sepiaValue.textContent = `${activeLayer.adjustments.sepia}%`;
DOM.adjGrayscale.value = activeLayer.adjustments.grayscale;
DOM.grayscaleValue.textContent = `${activeLayer.adjustments.grayscale}%`;
DOM.adjInvert.value = activeLayer.adjustments.invert;
DOM.invertValue.textContent = `${activeLayer.adjustments.invert}%`;
DOM.filterBlur.value = activeLayer.adjustments.blur;
DOM.blurValue.textContent = activeLayer.adjustments.blur;
}
} else {
DOM.layerOpacitySlider.value = 1;
DOM.layerOpacityValue.textContent = '100%';
DOM.layerBlendModeSelect.value = 'source-over';
}
};
const flattenImage = () => {
if (!confirm(lang.flattenConfirm)) return;
if (state.layers.length <= 1) return;
const flattenedCanvas = createFlattenedCanvas();
const newImg = new Image();
newImg.onload = () => {
state.layers = [{
type: 'image', name: lang.flattenedImage, content: newImg,
x: 0, y: 0, width: state.logicalWidth, height: state.logicalHeight, visible: true,
opacity: 1.0, blendMode: 'source-over', adjustments: { ...CONSTANTS.ADJUSTMENT_DEFAULTS }, filterApplied: null
}];
setActiveLayer(0);
fitToScreen();
updateExportPreview();
};
newImg.src = flattenedCanvas.toDataURL();
};
const saveProject = () => {
const projectData = {
logicalWidth: state.logicalWidth,
logicalHeight: state.logicalHeight,
layers: state.layers.map(layer => {
const layerCopy = { ...layer };
if (layerCopy.type === 'image' && layerCopy.content instanceof Image) {
const tempCanvas = document.createElement('canvas');
tempCanvas.width = layerCopy.width;
tempCanvas.height = layerCopy.height;
tempCanvas.getContext('2d').drawImage(layerCopy.content, 0, 0);
layerCopy.content = tempCanvas.toDataURL();
}
return layerCopy;
})
};
const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData));
const downloadAnchorNode = document.createElement('a');
downloadAnchorNode.setAttribute("href", dataStr);
downloadAnchorNode.setAttribute("download", "bildeprosjekt.json");
document.body.appendChild(downloadAnchorNode);
downloadAnchorNode.click();
downloadAnchorNode.remove();
};
const loadProject = (jsonString) => {
try {
const projectData = JSON.parse(jsonString);
state.logicalWidth = projectData.logicalWidth;
state.logicalHeight = projectData.logicalHeight;
state.currentAspectRatio = state.logicalWidth / state.logicalHeight;
DOM.resizeWidthInput.value = state.logicalWidth;
DOM.resizeHeightInput.value = state.logicalHeight;
state.layers = [];
let layersLoadedCount = 0;
const totalLayers = projectData.layers.length;
if (totalLayers === 0) {
initDefaultBackground();
return;
}
projectData.layers.forEach((layerData, index) => {
const newLayerData = {
...layerData,
opacity: layerData.opacity ?? 1.0,
blendMode: layerData.blendMode ?? 'source-over',
adjustments: layerData.adjustments ?? { ...CONSTANTS.ADJUSTMENT_DEFAULTS },
filterApplied: layerData.filterApplied ?? null,
visible: layerData.visible ?? true,
};
if (layerData.type === 'image' && typeof layerData.content === 'string') {
const img = new Image();
img.onload = () => {
state.layers[index] = { ...newLayerData, content: img };
layersLoadedCount++;
if (layersLoadedCount === totalLayers) onAllLayersLoaded();
};
img.onerror = () => {
console.error(`Kunne ikke laste bilde for lag ${layerData.name}`);
layersLoadedCount++;
if (layersLoadedCount === totalLayers) onAllLayersLoaded();
};
img.src = layerData.content;
} else {
state.layers[index] = newLayerData;
layersLoadedCount++;
if (layersLoadedCount === totalLayers) onAllLayersLoaded();
}
});
function onAllLayersLoaded() {
setActiveLayer(state.layers.length > 0 ? state.layers.length - 1 : -1);
fitToScreen();
updateExportPreview();
}
} catch (e) {
console.error(lang.projectLoadError, e);
alert(lang.projectLoadError);
}
};
// =================================================================================
// SECTION: Mouse Event Handlers
// =================================================================================
function handleMouseDown(e) {
if (e.button === CONSTANTS.PAN_BUTTON || (e.button === 0 && e.altKey && state.currentTool !== CONSTANTS.TOOLS.MOVE)) {
state.status.isPanning = true;
DOM.canvas.style.cursor = 'grabbing';
return;
}
if (e.button !== 0) return;
const pos = getMousePos(e);
state.mouse.startX = pos.x;
state.mouse.startY = pos.y;
state.mouse.isDown = true;
if (state.currentTool === CONSTANTS.TOOLS.MOVE && state.activeLayerIndex !== -1 && state.layers[state.activeLayerIndex].visible) {
const layer = state.layers[state.activeLayerIndex];
const handles = getHandles({ x: layer.x, y: layer.y, w: layer.width, h: layer.height });
const handleSize = 10 / state.zoom;
for (const handleName in handles) {
const handlePos = handles[handleName];
if (Math.abs(pos.x - handlePos.x) < handleSize / 2 && Math.abs(pos.y - handlePos.y) < handleSize / 2) {
state.status.isResizingLayer = true;
state.mouse.activeHandle = handleName;
state.mouse.originalLayerState = { ...layer };
DOM.canvas.style.cursor = getCursorForHandle(handleName);
return;
}
}
}
if (state.currentTool === CONSTANTS.TOOLS.CROP && state.cropRect.w !== 0 && state.cropRect.h !== 0) {
const normCrop = getNormalizedRect(state.cropRect);
const handles = getHandles(normCrop);
const handleSize = 10 / state.zoom;
for (const handleName in handles) {
const handlePos = handles[handleName];
if (Math.abs(pos.x - handlePos.x) < handleSize / 2 && Math.abs(pos.y - handlePos.y) < handleSize / 2) {
state.status.isResizingCrop = true;
state.mouse.activeHandle = handleName;
state.mouse.originalLayerState = { ...state.cropRect };
DOM.canvas.style.cursor = getCursorForHandle(handleName);
return;
}
}
if (pos.x >= normCrop.x && pos.x <= normCrop.x + normCrop.w && pos.y >= normCrop.y && pos.y <= normCrop.y + normCrop.h) {
state.status.isMovingCrop = true;
state.mouse.dragOffsetX = pos.x - state.cropRect.x;
state.mouse.dragOffsetY = pos.y - state.cropRect.y;
DOM.canvas.style.cursor = 'move';
return;
}
}
if (state.currentTool === CONSTANTS.TOOLS.MOVE) {
let clickedIdx = -1;
for (let i = state.layers.length - 1; i >= 0; i--) {
const l = state.layers[i];
if (l.visible && pos.x >= l.x && pos.x <= l.x + l.width && pos.y >= l.y && pos.y <= l.y + l.height) {
clickedIdx = i; break;
}
}
if (clickedIdx !== -1) {
state.status.isDragging = true;
setActiveLayer(clickedIdx);
state.mouse.dragOffsetX = pos.x - state.layers[clickedIdx].x;
state.mouse.dragOffsetY = pos.y - state.layers[clickedIdx].y;
DOM.canvas.style.cursor = 'grabbing';
}
} else if (state.currentTool === CONSTANTS.TOOLS.CROP) {
state.status.isCropping = true;
state.cropRect = { x: state.mouse.startX, y: state.mouse.startY, w: 0, h: 0 };
DOM.cropOptions.style.display = 'none';
}
}
function handleMouseMove(e) {
if (state.status.isPanning) {
state.panX += e.movementX;
state.panY += e.movementY;
redrawCanvas();
return;
}
if (!state.mouse.isDown) {
updateCursor(e);
return;
}
const pos = getMousePos(e);
if (state.status.isResizingLayer) handleLayerResize(pos, e.shiftKey, e.altKey);
else if (state.status.isResizingCrop) handleCropResize(pos);
else if (state.status.isMovingCrop) handleCropMove(pos);
else if (state.status.isDragging) handleLayerDrag(pos);
else if (state.status.isCropping) handleCropDraw(pos, e.clientX, e.clientY);
}
function handleMouseUp() {
if (state.status.isCropping || state.status.isResizingCrop) {
state.cropRect = getNormalizedRect(state.cropRect);
}
if (state.status.isCropping) {
if (Math.abs(state.cropRect.w) > 5 || Math.abs(state.cropRect.h) > 5) {
DOM.cropOptions.style.display = 'flex';
} else {
DOM.cropOptions.style.display = 'none';
state.cropRect = { x: 0, y: 0, w: 0, h: 0 };
redrawCanvas();
}
}
if (state.status.isResizingLayer || state.status.isDragging) {
updateExportPreview();
}
DOM.cropInfo.style.display = 'none';
for (let key in state.status) {
state.status[key] = false;
}
state.mouse.isDown = false;
state.mouse.activeHandle = null;
updateCursor();
}
function handleLayerDrag(pos) {
state.layers[state.activeLayerIndex].x = pos.x - state.mouse.dragOffsetX;
state.layers[state.activeLayerIndex].y = pos.y - state.mouse.dragOffsetY;
redrawCanvas();
}
function handleCropDraw(pos, clientX, clientY) {
state.cropRect.w = pos.x - state.mouse.startX;
state.cropRect.h = pos.y - state.mouse.startY;
const normCrop = getNormalizedRect(state.cropRect);
DOM.cropInfo.style.display = 'block';
DOM.cropInfo.style.left = `${clientX}px`;
DOM.cropInfo.style.top = `${clientY}px`;
DOM.cropInfo.textContent = `${Math.round(normCrop.w)} x ${Math.round(normCrop.h)} px`;
redrawCanvas();
}
function handleCropMove(pos) {
state.cropRect.x = pos.x - state.mouse.dragOffsetX;
state.cropRect.y = pos.y - state.mouse.dragOffsetY;
redrawCanvas();
}
function handleLayerResize(pos, shiftKey, altKey) {
const layer = state.layers[state.activeLayerIndex];
const dx = pos.x - state.mouse.startX;
const dy = pos.y - state.mouse.startY;
let { x, y, width, height } = state.mouse.originalLayerState;
const aspect = width / height;
let newX = x, newY = y, newW = width, newH = height;
switch (state.mouse.activeHandle) {
case 'topLeft': newW = width - dx; newH = height - dy; newX = x + dx; newY = y + dy; if (shiftKey) { newH = newW / aspect; newY = y + (height - newH); } break;
case 'topMiddle': newH = height - dy; newY = y + dy; break;
case 'topRight': newW = width + dx; newH = height - dy; newY = y + dy; if (shiftKey) { newH = newW / aspect; newY = y + (height - newH); } break;
case 'middleLeft': newW = width - dx; newX = x + dx; break;
case 'middleRight': newW = width + dx; break;
case 'bottomLeft': newW = width - dx; newH = height + dy; newX = x + dx; if (shiftKey) { newH = newW / aspect; } break;
case 'bottomMiddle': newH = height + dy; break;
case 'bottomRight': newW = width + dx; newH = height + dy; if (shiftKey) { newH = newW / aspect; } break;
}
if (altKey) {
const dW = newW - width; const dH = newH - height;
newX -= dW / 2; newY -= dH / 2;
}
if (layer.type === 'text') {
const scaleFactor = newW / state.mouse.originalLayerState.width;
const newFontSize = state.mouse.originalLayerState.fontSize * scaleFactor;
if (newFontSize >= 5) {
layer.fontSize = newFontSize;
DOM.ctx.font = `${layer.fontSize}px ${layer.font}`;
const metrics = DOM.ctx.measureText(layer.content);
layer.width = metrics.width;
layer.height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
layer.x = newX; layer.y = newY;
}
} else {
if (newW > 10) { layer.x = newX; layer.width = newW; }
if (newH > 10) { layer.y = newY; layer.height = newH; }
}
redrawCanvas();
}
function handleCropResize(pos) {
const dx = pos.x - state.mouse.startX;
const dy = pos.y - state.mouse.startY;
let { x, y, w, h } = state.mouse.originalLayerState;
switch (state.mouse.activeHandle) {
case 'topLeft': w -= dx; h -= dy; x += dx; y += dy; break;
case 'topMiddle': h -= dy; y += dy; break;
case 'topRight': w += dx; h -= dy; y += dy; break;
case 'middleLeft': w -= dx; x += dx; break;
case 'middleRight': w += dx; break;
case 'bottomLeft': w -= dx; h += dy; x += dx; break;
case 'bottomMiddle': h += dy; break;
case 'bottomRight': w += dx; h += dy; break;
}
state.cropRect = { x, y, w, h };
redrawCanvas();
}
function updateCursor(e) {
if (state.mouse.isDown) return;
const pos = e ? getMousePos(e) : null;
let newCursor = 'default';
if (state.currentTool === CONSTANTS.TOOLS.MOVE) {
newCursor = 'grab';
if (pos && state.activeLayerIndex !== -1 && state.layers[state.activeLayerIndex].visible) {
const layer = state.layers[state.activeLayerIndex];
const handles = getHandles({ x: layer.x, y: layer.y, w: layer.width, h: layer.height });
const handleSize = 10 / state.zoom;
for (const handleName in handles) {
const handlePos = handles[handleName];
if (Math.abs(pos.x - handlePos.x) < handleSize / 2 && Math.abs(pos.y - handlePos.y) < handleSize / 2) {
newCursor = getCursorForHandle(handleName); break;
}
}
}
} else if (state.currentTool === CONSTANTS.TOOLS.CROP) {
newCursor = 'crosshair';
if (pos && state.cropRect.w !== 0) {
const normCrop = getNormalizedRect(state.cropRect);
const handles = getHandles(normCrop);
const handleSize = 10 / state.zoom;
let onHandle = false;
for (const handleName in handles) {
const handlePos = handles[handleName];
if (Math.abs(pos.x - handlePos.x) < handleSize / 2 && Math.abs(pos.y - handlePos.y) < handleSize / 2) {
newCursor = getCursorForHandle(handleName); onHandle = true; break;
}
}
if (!onHandle && pos.x >= normCrop.x && pos.x <= normCrop.x + normCrop.w && pos.y >= normCrop.y && pos.y <= normCrop.y + normCrop.h) {
newCursor = 'move';
}
}
}
DOM.canvas.style.cursor = newCursor;
}
// =================================================================================
// SECTION: Initialization & Event Listeners
// =================================================================================
function setupEventListeners() {
DOM.toolMoveBtn.addEventListener('click', () => switchTool(CONSTANTS.TOOLS.MOVE));
DOM.toolCropBtn.addEventListener('click', () => switchTool(CONSTANTS.TOOLS.CROP));
DOM.toolTextBtn.addEventListener('click', () => switchTool(CONSTANTS.TOOLS.TEXT));
DOM.openBtn.addEventListener('click', () => { DOM.fileInput.dataset.mode = ''; DOM.fileInput.click(); });
DOM.importBtn.addEventListener('click', () => { DOM.fileInput.dataset.mode = 'import'; DOM.fileInput.click(); });
DOM.fileInput.addEventListener('change', (e) => {
const file = e.target.files[0]; if (!file) return;
const reader = new FileReader();
reader.onload = (event) => {
const img = new Image();
img.onload = () => loadImageToLayer(img, file.name, e.target.dataset.mode !== 'import');
img.src = event.target.result;
};
reader.readAsDataURL(file);
DOM.fileInput.value = '';
});
DOM.pasteBtn.addEventListener('click', pasteFromClipboard);
DOM.saveProjectBtn.addEventListener('click', saveProject);
DOM.loadProjectBtn.addEventListener('click', () => DOM.projectInput.click());
DOM.projectInput.addEventListener('change', (e) => {
const file = e.target.files[0]; if (!file) return;
const reader = new FileReader();
reader.onload = (event) => loadProject(event.target.result);
reader.readAsText(file);
DOM.projectInput.value = '';
});
DOM.flattenBtn.addEventListener('click', flattenImage);
DOM.resizeWidthInput.addEventListener('input', () => {
if (DOM.keepProportionsCheckbox.checked) {
const newWidth = parseInt(DOM.resizeWidthInput.value, 10);
if (!isNaN(newWidth) && newWidth > 0) { DOM.resizeHeightInput.value = Math.round(newWidth / state.currentAspectRatio); }
}
});
DOM.resizeHeightInput.addEventListener('input', () => {
if (DOM.keepProportionsCheckbox.checked) {
const newHeight = parseInt(DOM.resizeHeightInput.value, 10);
if (!isNaN(newHeight) && newHeight > 0) { DOM.resizeWidthInput.value = Math.round(newHeight * state.currentAspectRatio); }
}
});
DOM.resizeBtn.addEventListener('click', () => {
const newWidth = parseInt(DOM.resizeWidthInput.value, 10);
const newHeight = parseInt(DOM.resizeHeightInput.value, 10);
if (isNaN(newWidth) || isNaN(newHeight) || newWidth <= 0 || newHeight <= 0) { return alert(lang.invalidSize); }
if (!confirm(lang.resizeConfirm)) return;
state.currentAspectRatio = newWidth / newHeight;
const flattenedCanvas = createFlattenedCanvas();
const tempCanvas = document.createElement('canvas');
tempCanvas.width = newWidth; tempCanvas.height = newHeight;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.imageSmoothingQuality = 'high';
tempCtx.drawImage(flattenedCanvas, 0, 0, state.logicalWidth, state.logicalHeight, 0, 0, newWidth, newHeight);
state.logicalWidth = newWidth; state.logicalHeight = newHeight;
const img = new Image();
img.onload = () => {
state.layers = [{
type: 'image', name: lang.resizedImage, content: img,
x: 0, y: 0, width: newWidth, height: newHeight, visible: true,
opacity: 1.0, blendMode: 'source-over', adjustments: { ...CONSTANTS.ADJUSTMENT_DEFAULTS }, filterApplied: null
}];
setActiveLayer(0); fitToScreen(); updateExportPreview();
};
img.src = tempCanvas.toDataURL();
});
DOM.canvasContainer.addEventListener('wheel', (e) => {
e.preventDefault();
const delta = e.deltaY > 0 ? -0.1 : 0.1;
if (e.ctrlKey || e.metaKey) { doZoom(delta, e.offsetX, e.offsetY); }
else { state.panX -= e.deltaX; state.panY -= e.deltaY; redrawCanvas(); }
}, { passive: false });
DOM.zoomInBtn.addEventListener('click', () => doZoom(0.2));
DOM.zoomOutBtn.addEventListener('click', () => doZoom(-0.2));
DOM.fitToScreenBtn.addEventListener('click', fitToScreen);
document.addEventListener('keydown', (e) => {
if (document.activeElement.tagName.match(/INPUT|SELECT/)) return;
if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') { e.preventDefault(); pasteFromClipboard(); return; }
const toolMap = { v: CONSTANTS.TOOLS.MOVE, c: CONSTANTS.TOOLS.CROP, t: CONSTANTS.TOOLS.TEXT };
if (toolMap[e.key.toLowerCase()]) switchTool(toolMap[e.key.toLowerCase()]);
if (e.key === 'Delete' || e.key === 'Backspace') deleteActiveLayer();
if (e.key === 'Enter' && state.currentTool === CONSTANTS.TOOLS.CROP && Math.abs(state.cropRect.w) > 0) applyCrop();
});
DOM.canvas.addEventListener('mousedown', handleMouseDown);
DOM.canvas.addEventListener('mousemove', handleMouseMove);
window.addEventListener('mouseup', handleMouseUp);
DOM.addTextBtn.addEventListener('click', () => {
const text = DOM.textInput.value; if (!text) return;
const color = DOM.textColorInput.value;
const font = DOM.fontSelect.value;
const fontSize = parseInt(DOM.fontSizeInput.value, 10);
const shadow = DOM.textShadowCheckbox.checked;
const tempCtx = document.createElement('canvas').getContext('2d');
tempCtx.font = `${fontSize}px ${font}`;
const metrics = tempCtx.measureText(text);
const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
addLayer({
type: 'text', name: `${lang.textLayer} "${text.substring(0, Math.min(text.length, 10))}..."`,
content: text, x: 0, y: 0, width: metrics.width, height, color, font, fontSize, shadow, visible: true
}, true);
switchTool(CONSTANTS.TOOLS.MOVE);
});
DOM.applyCropBtn.addEventListener('click', applyCrop);
DOM.layerUpBtn.addEventListener('click', () => moveLayer(1));
DOM.layerDownBtn.addEventListener('click', () => moveLayer(-1));
DOM.layerDuplicateBtn.addEventListener('click', duplicateActiveLayer);
DOM.layerDeleteBtn.addEventListener('click', deleteActiveLayer);
DOM.layerOpacitySlider.addEventListener('input', () => {
const layer = state.layers[state.activeLayerIndex];
if (layer) {
layer.opacity = parseFloat(DOM.layerOpacitySlider.value);
DOM.layerOpacityValue.textContent = `${Math.round(layer.opacity * 100)}%`;
redrawCanvas();
updateExportPreview();
}
});
DOM.layerBlendModeSelect.addEventListener('change', () => {
const layer = state.layers[state.activeLayerIndex];
if (layer) {
layer.blendMode = DOM.layerBlendModeSelect.value;
redrawCanvas();
updateExportPreview();
}
});
const adjustmentInputs = [
{ id: DOM.adjBrightness, key: 'brightness', display: DOM.brightnessValue },
{ id: DOM.adjContrast, key: 'contrast', display: DOM.contrastValue },
{ id: DOM.adjSaturation, key: 'saturation', display: DOM.saturationValue },
{ id: DOM.adjHue, key: 'hue', display: DOM.hueValue },
{ id: DOM.adjSepia, key: 'sepia', display: DOM.sepiaValue, suffix: '%' },
{ id: DOM.adjGrayscale, key: 'grayscale', display: DOM.grayscaleValue, suffix: '%' },
{ id: DOM.adjInvert, key: 'invert', display: DOM.invertValue, suffix: '%' },
];
adjustmentInputs.forEach(item => {
item.id.addEventListener('input', () => {
const layer = state.layers[state.activeLayerIndex];
if (layer && layer.type === 'image') {
layer.adjustments[item.key] = parseFloat(item.id.value);
item.display.textContent = `${item.id.value}${item.suffix || ''}`;
redrawCanvas();
updateExportPreview();
}
});
});
DOM.filterBlur.addEventListener('input', () => {
const layer = state.layers[state.activeLayerIndex];
if (layer && layer.type === 'image') {
layer.adjustments.blur = parseFloat(DOM.filterBlur.value);
DOM.blurValue.textContent = layer.adjustments.blur;
redrawCanvas();
updateExportPreview();
}
});
const applyPermanentFilter = (filterType) => {
const layer = state.layers[state.activeLayerIndex];
if (layer && layer.type === 'image') {
layer.filterApplied = filterType;
redrawCanvas();
// To make it permanent, we need to re-render the layer's content
const tempCanvas = document.createElement('canvas');
tempCanvas.width = layer.width;
tempCanvas.height = layer.height;
const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
tempCtx.drawImage(layer.content, 0, 0, layer.width, layer.height);
const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
applyConvolutionFilter(imageData, filterType);
tempCtx.putImageData(imageData, 0, 0);
const newImg = new Image();
newImg.onload = () => {
layer.content = newImg;
layer.filterApplied = null;
redrawCanvas();
updateExportPreview();
};
newImg.src = tempCanvas.toDataURL();
}
};
DOM.filterSharpenBtn.addEventListener('click', () => applyPermanentFilter('sharpen'));
DOM.filterEmbossBtn.addEventListener('click', () => applyPermanentFilter('emboss'));
DOM.exportFormatSelect.addEventListener('change', updateExportPreview);
DOM.exportQualitySlider.addEventListener('input', updateExportPreview);
DOM.exportBtn.addEventListener('click', () => {
const link = document.createElement('a');
const ext = DOM.exportFormatSelect.value.split('/')[1];
link.download = `redigert_bilde.${ext === 'jpeg' ? 'jpg' : ext}`;
const flattenedCanvas = createFlattenedCanvas();
link.href = flattenedCanvas.toDataURL(DOM.exportFormatSelect.value, parseFloat(DOM.exportQualitySlider.value));
link.click();
link.remove();
});
}
function initDefaultBackground() {
const bgCanvas = document.createElement('canvas');
bgCanvas.width = state.logicalWidth;
bgCanvas.height = state.logicalHeight;
bgCanvas.getContext('2d').fillStyle = 'white';
bgCanvas.getContext('2d').fillRect(0, 0, state.logicalWidth, state.logicalHeight);
addLayer({
type: 'image', name: lang.backgroundLayer, content: bgCanvas,
x: 0, y: 0, width: state.logicalWidth, height: state.logicalHeight, visible: true,
opacity: 1.0, blendMode: 'source-over', adjustments: { ...CONSTANTS.ADJUSTMENT_DEFAULTS }, filterApplied: null
});
}
function init() {
updateStaticUIText();
DOM.resizeWidthInput.value = state.logicalWidth;
DOM.resizeHeightInput.value = state.logicalHeight;
initDefaultBackground();
updateCanvasSize();
fitToScreen();
switchTool(CONSTANTS.TOOLS.MOVE);
setupEventListeners();
updateExportPreview();
}
window.addEventListener('resize', () => { updateCanvasSize(); fitToScreen(); });
init();
});
</script>
</body>
</html>
